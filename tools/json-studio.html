<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>JSON Studio</title>

  <!-- JSON editor dark theme CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/vanilla-jsoneditor@3.5.0/themes/jse-theme-dark.css"
  />

  <style>
    :root {
      --app-bg: #0b1220;
      --app-accent: #60a5fa;
      --app-accent-soft: #3f6212;
      --app-border: rgba(148,163,184,.18);
      --app-text: #e5e7eb;
      --app-muted: #94a3b8;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: var(--app-bg);
      color: var(--app-text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .app-header {
      padding: 8px 12px;
      background: linear-gradient(
        90deg,
        var(--app-accent-soft),
        var(--app-accent)
      );
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      color: white;
    }

    .app-title {
      font-weight: 600;
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .app-title span {
      opacity: 0.9;
    }

    .tabs-bar {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      max-width: 320px;
    }

    .tab {
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid rgba(15, 23, 42, 0.5);
      background: rgba(15, 23, 42, 0.4);
      color: var(--app-muted);
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s, color 0.15s, border-color 0.15s;
      max-width: 140px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .tab.active {
      background: white;
      color: #111827;
      border-color: transparent;
      font-weight: 600;
    }

    .tab .label {
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tab .close {
      font-size: 11px;
      opacity: 0.65;
      padding-left: 2px;
    }

    .tab .close:hover {
      opacity: 1;
    }

    .tab-add {
      border-radius: 999px;
      border: 1px dashed rgba(241, 245, 249, 0.7);
      background: transparent;
      color: white;
      font-size: 14px;
      width: 26px;
      height: 26px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
    }

    .tab-add:hover {
      background: rgba(15, 23, 42, 0.5);
    }

    .app-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .toolbar {
      padding: 6px 10px;
      border-bottom: 1px solid var(--app-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: #111827;
      font-size: 12px;
      flex-wrap: wrap;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .toolbar label {
      color: var(--app-muted);
      font-size: 11px;
    }

    select {
      background: #020617;
      color: var(--app-text);
      border-radius: 999px;
      border: 1px solid var(--app-border);
      padding: 2px 8px;
      font-size: 11px;
    }

    button.icon-btn {
      border-radius: 999px;
      border: 1px solid var(--app-border);
      background: #020617;
      color: var(--app-text);
      font-size: 11px;
      padding: 4px 10px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    button.icon-btn:hover {
      background: #0f172a;
    }

    .editors-row {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    .editor-wrapper {
      flex: 1 1 auto;
      min-width: 0;
      border-right: 1px solid var(--app-border);
      display: flex;
      flex-direction: column;
    }

    .editor-wrapper:last-child {
      border-right: none;
    }

    .editor-title {
      padding: 4px 10px;
      font-size: 12px;
      border-bottom: 1px solid var(--app-border);
      background: #020617;
      color: var(--app-muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .editor-container {
      flex: 1;
      min-height: 0;
    }

    .editor-container.jse-theme-dark {
      height: 100%;
    }

    .center-controls {
      width: 80px;
      border-left: 1px solid var(--app-border);
      border-right: 1px solid var(--app-border);
      background: #020617;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px 6px;
      gap: 8px;
      font-size: 11px;
      user-select: none;
    }

    .center-controls button {
      width: 100%;
      justify-content: center;
    }

    .center-controls .hint {
      font-size: 10px;
      color: var(--app-muted);
      text-align: center;
      margin-top: 4px;
    }

    .diff-panel {
      border-top: 1px solid var(--app-border);
      padding: 6px 10px;
      font-size: 11px;
      background: #020617;
      max-height: 160px;
      overflow: auto;
    }

    .diff-panel pre {
      margin: 4px 0 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      word-break: break-word;
      color: #e5e7eb;
    }

    .diff-panel strong {
      color: var(--app-muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 10px;
    }

    @media (max-width: 900px) {
      .editors-row {
        flex-direction: column;
      }

      .center-controls {
        flex-direction: row;
        width: 100%;
        border-left: none;
        border-right: none;
        border-top: 1px solid var(--app-border);
      }

      .center-controls button {
        width: auto;
      }
    }

    /* --- Log reconstructor panel styling (scoped) --- */
    .log-tool-container {
      border-top: 1px solid var(--app-border);
      background: #020617;
      padding: 10px;
      overflow: auto;
      display: none; /* toggled via JS */
      height: 45vh;
      min-height: 220px;
      max-height: 85vh;
      resize: vertical; /* user can drag to resize bottom panels */
    }

    .log-tool-inner {
      max-width: 900px;
      margin: 0 auto;
      color: #e5e7eb;
    }

    .log-tool-inner.wide {
      max-width: 1200px;
      margin: 0;
      width: 100%;
    }

    .log-tool-inner h1 {
      font-size: 1.2rem;
      margin: 0 0 0.5rem;
    }

    .log-card {
      border: 1px solid #374151;
      border-radius: 8px;
      padding: 0.9rem 1rem;
      margin-top: 0.8rem;
      background: #111827;
    }

    .log-tool-inner label {
      display: inline-block;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .log-tool-inner input[type="file"] {
      margin-top: 0.25rem;
      color: #e5e7eb;
    }

    .log-status {
      margin-top: 0.75rem;
      font-size: 0.9rem;
    }

    .log-status span {
      font-weight: 600;
    }

    .log-tool-inner code {
      background: #1f2933;
      padding: 0.1rem 0.3rem;
      border-radius: 4px;
    }

    .log-tool-inner ul {
      padding-left: 1.2rem;
    }

    .log-tool-inner h2 {
      font-size: 1.05rem;
      margin-top: 0;
    }

    .log-inject {
      margin-top: 0.6rem;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      flex-wrap: wrap;
    }

    .log-inject span {
      color: var(--app-muted);
    }

    .log-inject button {
      border-radius: 999px;
      border: 1px solid var(--app-border);
      background: #020617;
      color: var(--app-text);
      font-size: 11px;
      padding: 3px 8px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .log-inject button:hover {
      background: #0f172a;
    }
  
    /* --- Value Extractor --------------------------------------------------- */
    .kv-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 900px) {
      .kv-grid { grid-template-columns: 1fr; }
    }
    .kv-keys {
      border: 1px solid var(--app-border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(2, 6, 23, 0.35);
      max-height: 260px;
      overflow: auto;
    }
    .kv-keys label {
      display: flex;
      gap: 8px;
      align-items: flex-start;
      padding: 6px 4px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      font-size: 0.9rem;
    }
    .kv-keys label:hover {
      background: rgba(148,163,184,.08);
    }
    .kv-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .kv-actions button {
      border-radius: 999px;
      border: 1px solid var(--app-border);
      background: rgba(2, 6, 23, 0.55);
      color: var(--app-text);
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
    }
    .kv-actions button:hover { border-color: rgba(96,165,250,.35); }
    .kv-output {
      width: 100%;
      min-height: 160px;
      border: 1px solid var(--app-border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(2, 6, 23, 0.35);
      color: var(--app-text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
  </style>
</head>

<body>
  <header class="app-header">
    <div class="app-title">
      <span>üîç JSON Side-by-Side</span>
      <span>¬∑ tree / text / table, compare & tabs</span>
    </div>
    <div class="tabs-bar">
      <div id="tabs" class="tabs"></div>
      <button id="add-tab" class="tab-add" title="New tab">+</button>
    </div>
  </header>

  <main class="app-main">
    <div class="toolbar">
      <div class="toolbar-group">
        <label for="left-mode">Left mode</label>
        <select id="left-mode">
          <option value="tree">Tree</option>
          <option value="text">Text</option>
          <option value="table">Table</option>
        </select>
      </div>
      <div class="toolbar-group">
        <button id="format-both" class="icon-btn" title="Format JSON on both sides">
          ‚è± Beautify both
        </button>
        <button id="load-sample-syncapp" class="icon-btn" title="Load sample SyncApp request/response into this tab">
          ‚ö° Load SyncApp sample
        </button>
      </div>
      <div class="toolbar-group">
        <label for="right-mode">Right mode</label>
        <select id="right-mode">
          <option value="tree">Tree</option>
          <option value="text">Text</option>
          <option value="table">Table</option>
        </select>
      </div>
      <div class="toolbar-group">
        <label>CSV</label>
        <button id="btn-import-left-csv" class="icon-btn" title="Import CSV into left editor">‚¨Ü Left</button>
        <button id="btn-export-left-csv" class="icon-btn" title="Export left JSON as CSV">‚¨á Left</button>
        <button id="btn-import-right-csv" class="icon-btn" title="Import CSV into right editor">‚¨Ü Right</button>
        <button id="btn-export-right-csv" class="icon-btn" title="Export right JSON as CSV">‚¨á Right</button>
      </div>
      <div class="toolbar-group">
        <button id="btn-clear-all" class="icon-btn" title="Clear editors and panels">üßπ Clear</button>
      </div>
      <div class="toolbar-group">
        <button id="toggle-log-tool" class="icon-btn" title="Show/Hide Coralogix log reconstructor">
          üß© Log Reconstructor
        </button>
        <button id="toggle-extract-tool" class="icon-btn" title="Show/Hide Nested JSON Key-Value Extractor">
          üß∞ Key-Value Extractor
        </button>
      </div>
    </div>

    <!-- Hidden file inputs for CSV import -->
    <input id="file-input-left-csv" type="file" accept=".csv,text/csv" style="display:none" />
    <input id="file-input-right-csv" type="file" accept=".csv,text/csv" style="display:none" />

    <div class="editors-row" id="editors-row">
      <section class="editor-wrapper" id="left-wrapper">
        <div class="editor-title">
          <span>Request / Left JSON</span>
        </div>
        <div id="left-editor" class="editor-container jse-theme-dark"></div>
      </section>

      <aside class="center-controls" id="center-controls" title="Drag here horizontally to resize left/right">
        <button id="copy-left-right" class="icon-btn" title="Copy left ‚Üí right">
          ‚Üê Copy
        </button>
        <button id="copy-right-left" class="icon-btn" title="Copy right ‚Üí left">
          Copy ‚Üí
        </button>
        <button id="compare" class="icon-btn" title="Compare JSON">
          ‚áÖ Compare
        </button>
        <button id="toggle-left-editor" class="icon-btn" title="Show/hide left editor">
          Hide L
        </button>
        <button id="toggle-right-editor" class="icon-btn" title="Show/hide right editor">
          Hide R
        </button>
        <div class="hint">Drag blank area to resize</div>
      </aside>

      <section class="editor-wrapper" id="right-wrapper">
        <div class="editor-title">
          <span>Response / Right JSON</span>
        </div>
        <div id="right-editor" class="editor-container jse-theme-dark"></div>
      </section>
    </div>

    <div class="diff-panel">
      <strong>Diff (parsed JSON)</strong>
      <pre id="diff-output">No comparison run yet.</pre>
    </div>

    <!-- Log reconstructor panel (from logpartrestructure.html) -->
    <div id="log-tool-container" class="log-tool-container">
      <div class="log-tool-inner">
        <h1>JSON Log Reconstructor for Coralogix</h1>

        <div class="log-card">
          <label for="fileInput">Upload your Coralogix log export (<code>.json</code>, <code>.log</code> or NDJSON):</label><br />
          <input
            id="fileInput"
            type="file"
            accept=".json,.log,.txt"
            onchange="processFile(event)"
          />

          <div id="status" class="log-status">Waiting for file...</div>

          <div id="log-inject" class="log-inject" style="display:none;">
            <span>Send reconstructed output directly into an editor:</span>
            <button id="inject-left" type="button">‚Üê Left editor</button>
            <button id="inject-right" type="button">Right editor ‚Üí</button>
          </div>
        </div>

        <div class="log-card">
          <h2>What this tool does</h2>
          <ul>
            <li>Accepts a Coralogix log export (JSON array, single JSON object, or NDJSON).</li>
            <li>Sorts the entries by the <code>LogPart</code> value (e.g. <code>1/15</code>, <code>2/15</code>, ...).</li>
            <li>From each entry, takes the <code>message</code> field, removes the leading <code>[n]</code> marker, and concatenates the parts in order.</li>
            <li>Tries to parse the concatenated string as JSON (and auto-adds missing closing brackets when possible) and pretty-prints it if valid.</li>
            <li>Downloads:
              <ul>
                <li><code>reconstructed_message.json</code> if the combined content is valid JSON, or</li>
                <li><code>reconstructed_message_raw.txt</code> if the content is not valid JSON (for manual inspection).</li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </div>
  
    <div id="extract-tool-container" class="log-tool-container">
      <div class="log-tool-inner wide">
        <h1>Nested JSON Key-Value Extractor</h1>

        <div class="log-card">
          <p style="margin-top:0;color:var(--app-muted);">
            Paste a <strong>JSON array</strong>, select keys (including nested dot-paths), and extract values.
            You can also load input directly from the left/right editor and inject extracted JSON back into an editor.
          </p>

          <label for="extractor-input" style="display:block;margin:10px 0 6px;color:var(--app-muted);">JSON input (array)</label>
          <textarea id="extractor-input" class="log-output" rows="8" placeholder='[{"a":{"b":1}}, {"a":{"b":2}}]'></textarea>

          <div class="kv-actions">
            <button id="extractor-use-left" type="button">Use Left JSON</button>
            <button id="extractor-use-right" type="button">Use Right JSON</button>
            <button id="extractor-refresh-keys" type="button">Refresh keys</button>
          </div>

          <div class="kv-grid" style="margin-top:12px;">
            <div>
              <div style="color:var(--app-muted);font-size:0.9rem;margin:0 0 6px;">Keys</div>
              <div id="extractor-keys" class="kv-keys"></div>
            </div>

            <div>
              <div style="color:var(--app-muted);font-size:0.9rem;margin:0 0 6px;">Preview</div>
              <output id="extractor-preview" class="kv-output"></output>
            </div>
          </div>

          <div class="kv-actions">
            <button id="extractor-run" type="button">Extract</button>
            <button id="extractor-copy-json" type="button">Copy extracted JSON</button>
            <button id="extractor-inject-left" type="button">‚Üê Inject to Left editor</button>
            <button id="extractor-inject-right" type="button">Inject to Right editor ‚Üí</button>
          </div>

          <label for="extractor-json-output" style="display:block;margin:10px 0 6px;color:var(--app-muted);">Extracted JSON (array of objects)</label>
          <textarea id="extractor-json-output" class="log-output" rows="7" placeholder="Extracted JSON will appear here..." readonly></textarea>
        </div>
      </div>
    </div>
  </main>

  <!-- Single module script combining both tools -->
  <script type="module">
    import { createJSONEditor } from "https://cdn.jsdelivr.net/npm/vanilla-jsoneditor@3.5.0/standalone.js";

    const STORAGE_KEY = "jsonSideToolTabs_v1";

    // --- Tab state ---------------------------------------------------------
    const tabs = [];
    let activeTabIndex = 0;

    function createEmptyTab(name) {
      return {
        id: Date.now() + Math.random(),
        name,
        left: {
          content: { text: "" },
          mode: "tree",
        },
        right: {
          content: { text: "" },
          mode: "tree",
        },
      };
    }

    function getActiveTab() {
      return tabs[activeTabIndex];
    }

    // --- Persistence -------------------------------------------------------
    function saveState() {
      try {
        const state = {
          tabs,
          activeTabIndex,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        // ignore if storage unavailable
      }
    }

    function sanitizeTab(raw, index) {
      const fallbackName = raw && raw.name ? String(raw.name) : "Tab " + (index + 1);
      return {
        id: raw && raw.id ? raw.id : Date.now() + Math.random(),
        name: fallbackName,
        left: {
          content:
            raw && raw.left && raw.left.content
              ? raw.left.content
              : { text: "" },
          mode:
            raw && raw.left && raw.left.mode
              ? raw.left.mode
              : "tree",
        },
        right: {
          content:
            raw && raw.right && raw.right.content
              ? raw.right.content
              : { text: "" },
          mode:
            raw && raw.right && raw.right.mode
              ? raw.right.mode
              : "tree",
        },
      };
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const state = JSON.parse(raw);
        if (!state || !Array.isArray(state.tabs) || state.tabs.length === 0) {
          return false;
        }
        tabs.length = 0;
        state.tabs.forEach((t, i) => {
          tabs.push(sanitizeTab(t, i));
        });
        activeTabIndex =
          typeof state.activeTabIndex === "number"
            ? Math.min(Math.max(state.activeTabIndex, 0), tabs.length - 1)
            : 0;
        return true;
      } catch (e) {
        return false;
      }
    }

    // --- DOM elements ------------------------------------------------------
    const tabsContainer = document.getElementById("tabs");
    const addTabButton = document.getElementById("add-tab");

    const leftModeSelect = document.getElementById("left-mode");
    const rightModeSelect = document.getElementById("right-mode");

    const copyLeftRightBtn = document.getElementById("copy-left-right");
    const copyRightLeftBtn = document.getElementById("copy-right-left");
    const compareBtn = document.getElementById("compare");
    const formatBothBtn = document.getElementById("format-both");
    const loadSampleBtn = document.getElementById("load-sample-syncapp");
    const diffOutput = document.getElementById("diff-output");

    const leftEditorContainer = document.getElementById("left-editor");
    const rightEditorContainer = document.getElementById("right-editor");

    const editorsRow = document.getElementById("editors-row");
    const leftWrapper = document.getElementById("left-wrapper");
    const rightWrapper = document.getElementById("right-wrapper");
    const centerControls = document.getElementById("center-controls");

    const btnImportLeftCSV = document.getElementById("btn-import-left-csv");
    const btnExportLeftCSV = document.getElementById("btn-export-left-csv");
    const btnImportRightCSV = document.getElementById("btn-import-right-csv");
    const btnExportRightCSV = document.getElementById("btn-export-right-csv");
    const fileInputLeftCSV = document.getElementById("file-input-left-csv");
    const fileInputRightCSV = document.getElementById("file-input-right-csv");

    const toggleLeftBtn = document.getElementById("toggle-left-editor");
    const toggleRightBtn = document.getElementById("toggle-right-editor");

    const toggleLogToolBtn = document.getElementById("toggle-log-tool");
    const logToolContainer = document.getElementById("log-tool-container");

	    const toggleExtractToolBtn = document.getElementById("toggle-extract-tool");
	    const extractToolContainer = document.getElementById("extract-tool-container");

    const logInjectContainer = document.getElementById("log-inject");
    const injectLeftBtn = document.getElementById("inject-left");
    const injectRightBtn = document.getElementById("inject-right");

    // --- Editors -----------------------------------------------------------
    const leftEditor = createJSONEditor({
      target: leftEditorContainer,
      props: {
        content: { text: "" },
        mode: "tree",
        mainMenuBar: true,
        navigationBar: true,
        statusBar: true,
        onChange: (content) => {
          const tab = getActiveTab();
          tab.left.content = content;
          saveState();
        },
        onChangeMode: (mode) => {
          const tab = getActiveTab();
          tab.left.mode = mode;
          leftModeSelect.value = mode;
          saveState();
        },
      },
    });

    const rightEditor = createJSONEditor({
      target: rightEditorContainer,
      props: {
        content: { text: "" },
        mode: "tree",
        mainMenuBar: true,
        navigationBar: true,
        statusBar: true,
        onChange: (content) => {
          const tab = getActiveTab();
          tab.right.content = content;
          saveState();
        },
        onChangeMode: (mode) => {
          const tab = getActiveTab();
          tab.right.mode = mode;
          rightModeSelect.value = mode;
          saveState();
        },
      },
    });

    // --- Tab rendering, switching, renaming -------------------------------
    function renderTabs() {
      tabsContainer.innerHTML = "";
      tabs.forEach((tab, index) => {
        const button = document.createElement("button");
        button.className = "tab" + (index === activeTabIndex ? " active" : "");
        button.type = "button";
        button.title = tab.name;

        const label = document.createElement("span");
        label.className = "label";
        label.textContent = tab.name;
        label.addEventListener("dblclick", (event) => {
          event.stopPropagation();
          renameTab(index);
        });
        button.appendChild(label);

        if (tabs.length > 1) {
          const close = document.createElement("span");
          close.className = "close";
          close.textContent = "√ó";
          close.addEventListener("click", (event) => {
            event.stopPropagation();
            closeTab(index);
          });
          button.appendChild(close);
        }

        button.addEventListener("click", () => switchToTab(index));
        tabsContainer.appendChild(button);
      });
    }

    function switchToTab(index) {
      activeTabIndex = index;
      const tab = getActiveTab();

      leftEditor.updateProps({
        content: tab.left.content,
        mode: tab.left.mode,
      });
      rightEditor.updateProps({
        content: tab.right.content,
        mode: tab.right.mode,
      });

      leftModeSelect.value = tab.left.mode;
      rightModeSelect.value = tab.right.mode;

      renderTabs();
      diffOutput.textContent = "No comparison run yet.";
      saveState();
    }

    function closeTab(index) {
      if (tabs.length === 1) return; // keep at least one
      tabs.splice(index, 1);
      if (activeTabIndex >= tabs.length) {
        activeTabIndex = tabs.length - 1;
      }
      renderTabs();
      switchToTab(activeTabIndex);
      saveState();
    }

    function addNewTab() {
      const n = tabs.length + 1;
      const tab = createEmptyTab("Tab " + n);
      tabs.push(tab);
      activeTabIndex = tabs.length - 1;
      renderTabs();
      switchToTab(activeTabIndex);
      saveState();
    }

    function renameTab(index) {
      const current = tabs[index];
      const newName = prompt("Rename tab:", current.name);
      if (!newName) return;
      current.name = newName.trim();
      renderTabs();
      saveState();
    }

    addTabButton.addEventListener("click", addNewTab);

    // --- Mode selectors ----------------------------------------------------
    leftModeSelect.addEventListener("change", () => {
      leftEditor.updateProps({ mode: leftModeSelect.value });
    });

    rightModeSelect.addEventListener("change", () => {
      rightEditor.updateProps({ mode: rightModeSelect.value });
    });

    // --- Copy helpers ------------------------------------------------------
    function copySide(sourceKey, targetKey) {
      const tab = getActiveTab();
      const source = tab[sourceKey];
      tab[targetKey].content = source.content;
      tab[targetKey].mode = source.mode;

      const editor = targetKey === "left" ? leftEditor : rightEditor;
      editor.updateProps({
        content: tab[targetKey].content,
        mode: tab[targetKey].mode,
      });

      if (targetKey === "left") {
        leftModeSelect.value = tab[targetKey].mode;
      } else {
        rightModeSelect.value = tab[targetKey].mode;
      }
      saveState();
    }

    copyLeftRightBtn.addEventListener("click", () => copySide("left", "right"));
    copyRightLeftBtn.addEventListener("click", () => copySide("right", "left"));

    // --- Diff logic --------------------------------------------------------
    function contentToJSON(content) {
      if (!content) return null;
      if ("json" in content && content.json !== undefined) {
        return content.json;
      }
      if ("text" in content && typeof content.text === "string") {
        if (!content.text.trim()) return null;
        try {
          return JSON.parse(content.text);
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    function diffJSON(a, b, path = "$", diffs = []) {
      if (a === b) return diffs;

      const aIsObj = a && typeof a === "object";
      const bIsObj = b && typeof b === "object";

      if (!aIsObj || !bIsObj) {
        diffs.push(
          `${path}: ${JSON.stringify(a)} ‚á¢ ${JSON.stringify(b)}`
        );
        return diffs;
      }

      const aKeys = Array.isArray(a) ? a.map((_, i) => String(i)) : Object.keys(a);
      const bKeys = Array.isArray(b) ? b.map((_, i) => String(i)) : Object.keys(b);
      const allKeys = new Set([...aKeys, ...bKeys]);

      allKeys.forEach((key) => {
        const aHas = key in a;
        const bHas = key in b;

        const nextPath = Array.isArray(a)
          ? `${path}[${key}]`
          : `${path}.${key}`;

        if (!aHas) {
          diffs.push(`${nextPath}: <missing> ‚á¢ ${JSON.stringify(b[key])}`);
        } else if (!bHas) {
          diffs.push(`${nextPath}: ${JSON.stringify(a[key])} ‚á¢ <missing>`);
        } else {
          diffJSON(a[key], b[key], nextPath, diffs);
        }
      });

      return diffs;
    }

    compareBtn.addEventListener("click", () => {
      const tab = getActiveTab();
      const leftJSON = contentToJSON(tab.left.content);
      const rightJSON = contentToJSON(tab.right.content);

      if (leftJSON === null || rightJSON === null) {
        diffOutput.textContent =
          "Cannot compare: one or both sides contain invalid or empty JSON (in text mode).";
        return;
      }

      const diffs = diffJSON(leftJSON, rightJSON);
      diffOutput.textContent =
        diffs.length === 0
          ? "No differences ‚Äì parsed JSON is identical."
          : diffs.join("\n");
    });

    // --- Beautify both sides ----------------------------------------------
    function beautifyEditor(editor, sideKey) {
      const tab = getActiveTab();
      const side = tab[sideKey];

      const json = contentToJSON(side.content);
      if (json === null) return;

      const pretty = JSON.stringify(json, null, 2);
      const newContent = { text: pretty };

      side.content = newContent;

      editor.updateProps({
        content: newContent,
      });
    }

    formatBothBtn.addEventListener("click", () => {
      beautifyEditor(leftEditor, "left");
      beautifyEditor(rightEditor, "right");
      saveState();
    });

    // --- Sample payload loader --------------------------------------------
    function loadSyncAppSample() {
      const leftSample = {
        json: {
          source: "SyncAppHttpLogger",
          request: {
            uri: "http://syncapp-netsuite:5000/api/v1/resources/payment?payerPublicId=12490645472003790876340000",
            method: "POST",
            body: {
              account: { internalId: 254 },
              entity: { internalId: 3775 },
              tranId: "CARD-092",
              applyList: {
                apply: [
                  {
                    doc: 22857,
                    type: "vendorBill",
                    apply: true,
                    amount: 279,
                  },
                ],
              },
              tranDate: "2025-11-04T09:00:00.000Z",
              currency: { internalId: 1 },
              subsidiary: { internalId: 99 },
              _class: { internalId: 3 },
              location: { internalId: 110 },
              department: { internalId: 24 },
              apAcct: { internalId: 25 },
            },
          },
        },
      };

      const rightSample = {
        json: {
          source: "SyncAppHttpLogger",
          request: {
            uri: "http://syncapp-netsuite:5000/api/v1/resources/payment?payerPublicId=12490645472003790876340000",
            method: "POST",
          },
          response: {
            status: 200,
            headers: {
              "content-type": "application/json",
            },
            body: {
              success: true,
              paymentId: "PAY-123456",
              message: "Payment created successfully",
            },
          },
        },
      };

      const tab = getActiveTab();
      tab.left.content = leftSample;
      tab.left.mode = "tree";
      tab.right.content = rightSample;
      tab.right.mode = "tree";

      leftEditor.updateProps({
        content: tab.left.content,
        mode: tab.left.mode,
      });
      rightEditor.updateProps({
        content: tab.right.content,
        mode:	tab.right.mode,
      });

      leftModeSelect.value = tab.left.mode;
      rightModeSelect.value = tab.right.mode;

      diffOutput.textContent = "No comparison run yet.";
      saveState();
    }

    loadSampleBtn.addEventListener("click", loadSyncAppSample);

    // --- CSV helpers -------------------------------------------------------
    function parseCSV(text) {
      const rows = [];
      let current = "";
      let row = [];
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === ",") {
            row.push(current);
            current = "";
          } else if (ch === "\r") {
            continue;
          } else if (ch === "\n") {
            row.push(current);
            rows.push(row);
            row = [];
            current = "";
          } else {
            current += ch;
          }
        }
      }
      if (current.length > 0 || row.length > 0) {
        row.push(current);
        rows.push(row);
      }
      return rows;
    }

    function csvRowsToObjects(rows) {
      if (!rows.length) return [];
      const headers = rows[0].map((h) => h.trim());
      const dataRows = rows.slice(1);
      return dataRows.map((r) => {
        const obj = {};
        headers.forEach((h, i) => {
          if (!h) return;
          obj[h] = r[i] !== undefined ? r[i] : "";
        });
        return obj;
      });
    }

    function objectsToCSV(objs) {
      if (!Array.isArray(objs) || objs.length === 0) return "";
      const headerSet = new Set();
      objs.forEach((o) => {
        if (o && typeof o === "object") {
          Object.keys(o).forEach((k) => headerSet.add(k));
        }
      });
      const headers = Array.from(headerSet);
      function escapeCell(value) {
        if (value === null || value === undefined) value = "";
        value = String(value);
        if (/[",\n]/.test(value)) {
          return '"' + value.replace(/"/g, '""') + '"';
        }
        return value;
      }
      const lines = [];
      lines.push(headers.map(escapeCell).join(","));
      objs.forEach((o) => {
        const row = headers.map((h) =>
          escapeCell(o && typeof o === "object" ? o[h] : "")
        );
        lines.push(row.join(","));
      });
      return lines.join("\n");
    }

    function importCSVToSide(sideKey, file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target.result;
        const rows = parseCSV(text);
        const objs = csvRowsToObjects(rows);
        const newContent = { json: objs };

        const tab = getActiveTab();
        tab[sideKey].content = newContent;
        tab[sideKey].mode = "table";

        const editor = sideKey === "left" ? leftEditor : rightEditor;
        editor.updateProps({
          content: newContent,
          mode: "table",
        });

        if (sideKey === "left") {
          leftModeSelect.value = "table";
        } else {
          rightModeSelect.value = "table";
        }

        saveState();
      };
      reader.readAsText(file);
    }

    function exportSideToCSV(sideKey) {
      const tab = getActiveTab();
      const json = contentToJSON(tab[sideKey].content);
      if (!Array.isArray(json)) {
        alert(
          "For CSV export, the " +
            sideKey +
            " side must contain an array of objects (e.g. [{...}, {...}])."
        );
        return;
      }
      const csvText = objectsToCSV(json);
      const blob = new Blob([csvText], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = sideKey + "-export.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    btnImportLeftCSV.addEventListener("click", () => fileInputLeftCSV.click());
    btnImportRightCSV.addEventListener("click", () => fileInputRightCSV.click());

    fileInputLeftCSV.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      importCSVToSide("left", file);
      fileInputLeftCSV.value = "";
    });

    fileInputRightCSV.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      importCSVToSide("right", file);
      fileInputRightCSV.value = "";
    });

    btnExportLeftCSV.addEventListener("click", () => exportSideToCSV("left"));
    btnExportRightCSV.addEventListener("click", () => exportSideToCSV("right"));

    // --- Resize logic ------------------------------------------------------
    let isResizing = false;

    centerControls.addEventListener("mousedown", (event) => {
      if (event.target.tagName === "BUTTON") return;
      isResizing = true;
      document.body.style.cursor = "col-resize";
    });

    window.addEventListener("mousemove", (event) => {
      if (!isResizing) return;
      const rect = editorsRow.getBoundingClientRect();
      let newLeftWidth = event.clientX - rect.left;
      const minWidth = 150;
      const maxWidth = rect.width - 150;
      if (newLeftWidth < minWidth) newLeftWidth = minWidth;
      if (newLeftWidth > maxWidth) newLeftWidth = maxWidth;

      leftWrapper.style.flex = "0 0 " + newLeftWidth + "px";
      rightWrapper.style.flex = "1 1 auto";
    });

    window.addEventListener("mouseup", () => {
      if (isResizing) {
        isResizing = false;
        document.body.style.cursor = "";
      }
    });

    // --- Show/hide editor screens -----------------------------------------
    let leftVisible = true;
    let rightVisible = true;

    function updateVisibility() {
      leftWrapper.style.display = leftVisible ? "flex" : "none";
      rightWrapper.style.display = rightVisible ? "flex" : "none";
      toggleLeftBtn.textContent = leftVisible ? "Hide L" : "Show L";
      toggleRightBtn.textContent = rightVisible ? "Hide R" : "Show R";
    }

    toggleLeftBtn.addEventListener("click", () => {
      leftVisible = !leftVisible;
      updateVisibility();
    });

    toggleRightBtn.addEventListener("click", () => {
      rightVisible = !rightVisible;
      updateVisibility();
    });

    // --- Toggle log tool panel --------------------------------------------
    let logVisible = false;
    toggleLogToolBtn.addEventListener("click", () => {
      logVisible = !logVisible;
      logToolContainer.style.display = logVisible ? "block" : "none";
      toggleLogToolBtn.textContent = logVisible ? "üß© Log Reconstructor ‚ñ≤" : "üß© Log Reconstructor";
    });

	    // --- Toggle extractor panel -------------------------------------------
	    let extractVisible = false;
	    toggleExtractToolBtn.addEventListener("click", () => {
	      extractVisible = !extractVisible;
	      extractToolContainer.style.display = extractVisible ? "block" : "none";
	      toggleExtractToolBtn.textContent = extractVisible ? "üß∞ Key-Value Extractor ‚ñ≤" : "üß∞ Key-Value Extractor";
	    });

    // --- Clear current tool state (does not remove any functionality) -------
    const clearAllBtn = document.getElementById("btn-clear-all");
    if (clearAllBtn) {
      clearAllBtn.addEventListener("click", () => {
        // Clear active tab editors
        const tab = getActiveTab();
        tab.left.content = { text: "" };
        tab.right.content = { text: "" };

        leftEditor.updateProps({ content: tab.left.content, mode: tab.left.mode });
        rightEditor.updateProps({ content: tab.right.content, mode: tab.right.mode });

        // Reset diff panel
        const diffOut = document.getElementById("diff-output");
        if (diffOut) diffOut.textContent = "No comparison run yet.";

        // Reset log reconstructor UI (file + status)
        const fileInput = document.getElementById("fileInput");
        if (fileInput) fileInput.value = "";
        const status = document.getElementById("status");
        if (status) status.textContent = "Waiting for file...";
        const logInject = document.getElementById("log-inject");
        if (logInject) logInject.style.display = "none";

        // Reset extractor UI
        const exIn = document.getElementById("extractor-input");
        if (exIn) exIn.value = "";
        const exKeys = document.getElementById("extractor-keys");
        if (exKeys) exKeys.innerHTML = "";
        const exPrev = document.getElementById("extractor-preview");
        if (exPrev) exPrev.textContent = "";
        const exOut = document.getElementById("extractor-json-output");
        if (exOut) exOut.value = "";

        saveState();
      });
    }


    // --- Log reconstructor logic (from logpartrestructure.html) -----------
    let lastReconstructedJson = null; // pretty JSON, if valid
    let lastReconstructedRaw = null;  // raw concatenated message (may be invalid JSON)

    function showStatus(message, isError = false) {
      const statusEl = document.getElementById("status");
      if (!statusEl) return;
      statusEl.textContent = message;
      statusEl.style.color = isError ? "#f87171" : "#4ade80";
      console.log("[STATUS]", message);
    }

    function parseLogContent(raw) {
      const content = (raw || "").trim();
      if (!content) {
        throw new Error("File is empty.");
      }

      // 1) Try as regular JSON
      try {
        const parsed = JSON.parse(content);
        return Array.isArray(parsed) ? parsed : [parsed];
      } catch (e1) {
        console.warn("JSON.parse(raw) failed, trying NDJSON...", e1);
      }

      // 2) NDJSON
      const lines = content
        .split(/\r?\n/)
        .map((l) => l.trim())
        .filter((l) => l.length > 0);
      const ndjson = [];
      let ndjsonFailures = 0;

      for (const line of lines) {
        try {
          ndjson.push(JSON.parse(line));
        } catch (e2) {
          ndjsonFailures++;
        }
      }

      if (ndjson.length > 0) {
        console.log("Parsed as NDJSON with", ndjson.length, "entries. Failed lines:", ndjsonFailures);
        return ndjson;
      }

      // 3) Last resort: wrap with [ ]
      try {
        let fixed = content;
        if (!fixed.startsWith("[")) fixed = "[" + fixed;
        if (!fixed.endsWith("]")) fixed = fixed + "]";
        const parsed = JSON.parse(fixed);
        return Array.isArray(parsed) ? parsed : [parsed];
      } catch (e3) {
        console.error("Could not parse content as JSON or NDJSON.", e3);
        throw new Error("File is not valid JSON / NDJSON. Please export your Coralogix log as JSON.");
      }
    }

    function getLogPartIndex(item) {
      const text = (item && item.text) ? item.text : (item || {});
      const raw =
        text.LogPart ||
        text.logPart ||
        text.log_part ||
        item.LogPart ||
        item.logPart ||
        item.log_part ||
        "";

      if (!raw) return Number.MAX_SAFE_INTEGER;

      const match = String(raw).match(/^(\d+)\s*\//);
      if (!match) return Number.MAX_SAFE_INTEGER;

      const num = parseInt(match[1], 10);
      return Number.isNaN(num) ? Number.MAX_SAFE_INTEGER : num;
    }

    function extractCleanedMessage(item) {
      const text = (item && item.text) ? item.text : (item || {});
      let rawMessage = text.message || item.message;

      if (!rawMessage) return "";

      rawMessage = String(rawMessage);
      const cleaned = rawMessage.replace(/^\s*\[\d+\]\s*/, "");
      return cleaned;
    }

    function autoFixClosingBrackets(str) {
      // Best-effort helper: if we're only missing closing braces/brackets,
      // append them at the end so JSON.parse has a chance to succeed.
      const count = (s, re) => (s.match(re) || []).length;

      const openCurly = count(str, /{/g);
      const closeCurly = count(str, /}/g);
      const openSquare = count(str, /\[/g);
      const closeSquare = count(str, /]/g);

      let fixed = str;
      if (closeCurly < openCurly) {
        fixed += "}".repeat(openCurly - closeCurly);
      }
      if (closeSquare < openSquare) {
        fixed += "]".repeat(openSquare - closeSquare);
      }
      return fixed;
    }

    function reconstructJsonFromParts(entries) {
      const sorted = entries.slice().sort((a, b) => getLogPartIndex(a) - getLogPartIndex(b));

      let combined = "";
      let used = 0;
      let emptyParts = 0;

      for (const entry of sorted) {
        const msg = extractCleanedMessage(entry);
        if (msg) {
          combined += msg;
          used++;
        } else {
          emptyParts++;
        }
      }

      if (!combined) {
        throw new Error("No message content found in the log parts.");
      }

      let pretty = "";
      let valid = false;
      let error = null;

      // First try as-is
      try {
        const obj = JSON.parse(combined);
        pretty = JSON.stringify(obj, null, 2);
        valid = true;
      } catch (e1) {
        // Try auto-fixing missing closing brackets
        try {
          const fixed = autoFixClosingBrackets(combined);
          const obj = JSON.parse(fixed);
          pretty = JSON.stringify(obj, null, 2);
          valid = true;
          console.warn("JSON needed auto-fix for closing brackets.");
        } catch (e2) {
          console.error("Combined message is not valid JSON, even after auto-fix:", e2);
          error = e2;
          pretty = combined; // raw output
        }
      }

      return {
        combined,
        pretty,
        valid,
        error,
        stats: { usedParts: used, emptyParts, totalParts: sorted.length },
      };
    }

    function downloadFile(filename, content) {
      const blob = new Blob([content], { type: "application/json" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function injectIntoEditor(sideKey) {
      if (!lastReconstructedRaw && !lastReconstructedJson) {
        alert("No reconstructed output is available yet. Please upload and reconstruct first.");
        return;
      }

      let mode;
      let content;

      if (lastReconstructedJson) {
        // Valid JSON: inject as parsed JSON in tree mode
        let parsed;
        try {
          parsed = JSON.parse(lastReconstructedJson);
        } catch (e) {
          // If for some reason parsing fails, fall back to raw text mode
          console.warn("Failed to parse stored JSON, falling back to text mode:", e);
          mode = "text";
          content = { text: lastReconstructedRaw || lastReconstructedJson };
        }

        if (parsed !== undefined) {
          mode = "tree";
          content = { json: parsed };
        }
      } else {
        // Invalid JSON: inject raw text into editor in text mode
        mode = "text";
        content = { text: lastReconstructedRaw };
      }

      const tab = getActiveTab();
      tab[sideKey].content = content;
      tab[sideKey].mode = mode;

      const editor = sideKey === "left" ? leftEditor : rightEditor;
      editor.updateProps({
        content,
        mode,
      });

      if (sideKey === "left") {
        leftModeSelect.value = mode;
      } else {
        rightModeSelect.value = mode;
      }

      diffOutput.textContent = "No comparison run yet.";
      saveState();
    }

    if (injectLeftBtn) {
      injectLeftBtn.addEventListener("click", () => injectIntoEditor("left"));
    }
    if (injectRightBtn) {
      injectRightBtn.addEventListener("click", () => injectIntoEditor("right"));
    }

    function processFile(event) {
      try {
        const file = event.target.files && event.target.files[0];
        if (!file) {
          showStatus("No file selected.", true);
          return;
        }

        showStatus("Reading file " + file.name + "...");

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const raw = e.target.result || "";
            const entries = parseLogContent(raw);

            showStatus("Parsed " + entries.length + " log entries. Reconstructing JSON from log parts...");

            const { combined, pretty, valid, error, stats } = reconstructJsonFromParts(entries);

            // Always store raw and (if valid) JSON output for injection
            lastReconstructedRaw = combined;
            lastReconstructedJson = valid ? pretty : null;

            if (logInjectContainer) {
              // Allow injection of either JSON (if valid) or raw text (if invalid)
              logInjectContainer.style.display = "flex";
            }

            const filename = valid ? "reconstructed_message.json" : "reconstructed_message_raw.txt";
            downloadFile(filename, pretty);

            let msg =
              "Done. Processed " +
              stats.totalParts +
              " log part(s); used " +
              stats.usedParts +
              ", empty/without message: " +
              stats.emptyParts +
              ".";

            if (valid) {
              msg += " Output is valid JSON in " + filename + ". You can also inject it into an editor using the buttons below.";
              showStatus(msg, false);
            } else {
              msg +=
                " However, the combined message is NOT valid JSON. Downloaded raw output as " +
                filename +
                " for inspection. You can still inject this raw output into an editor.";
              console.warn("Combined JSON parse error:", error);
              showStatus(msg, true);
            }
          } catch (innerErr) {
            console.error("Error while processing file:", innerErr);
            showStatus("Error while processing file: " + innerErr.message, true);
            lastReconstructedRaw = null;
            lastReconstructedJson = null;
            if (logInjectContainer) {
              logInjectContainer.style.display = "none";
            }
          }
        };

        reader.onerror = function () {
          showStatus("Error reading the file. Please try again.", true);
          lastReconstructedRaw = null;
          lastReconstructedJson = null;
          if (logInjectContainer) {
            logInjectContainer.style.display = "none";
          }
        };

        reader.readAsText(file);
      } catch (err) {
        console.error("Unexpected error in processFile:", err);
        showStatus("Unexpected error while processing the file: " + err.message, true);
        lastReconstructedRaw = null;
        lastReconstructedJson = null;
        if (logInjectContainer) {
          logInjectContainer.style.display = "none";
        }
      }
    }

    // Expose processFile globally for the onchange handler
    window.processFile = processFile;

    // --- Initial setup -----------------------------------------------------
    const loaded = loadState();
    if (!loaded) {
      tabs.push(createEmptyTab("Tab 1"));
      activeTabIndex = 0;
    }
    renderTabs();
    switchToTab(activeTabIndex);
    updateVisibility();
  

    // --- Nested JSON Key-Value Extractor (integrated) ----------------------
    const extractorInput = document.getElementById("extractor-input");
    const extractorKeys = document.getElementById("extractor-keys");
    const extractorPreview = document.getElementById("extractor-preview");
    const extractorJsonOutput = document.getElementById("extractor-json-output");

    const btnExtractorUseLeft = document.getElementById("extractor-use-left");
    const btnExtractorUseRight = document.getElementById("extractor-use-right");
    const btnExtractorRefresh = document.getElementById("extractor-refresh-keys");
    const btnExtractorRun = document.getElementById("extractor-run");
    const btnExtractorCopy = document.getElementById("extractor-copy-json");
    const btnExtractorInjectLeft = document.getElementById("extractor-inject-left");
    const btnExtractorInjectRight = document.getElementById("extractor-inject-right");

    function extractor_collectKeys(obj, keySet, prefix = "") {
      if (!obj || typeof obj !== "object" || Array.isArray(obj)) return;
      for (const [key, value] of Object.entries(obj)) {
        const fullKey = prefix ? `${prefix}.${key}` : key;
        keySet.add(fullKey);
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
          extractor_collectKeys(value, keySet, fullKey);
        }
      }
    }

    function extractor_getNestedValue(obj, parts) {
      let current = obj;
      for (const part of parts) {
        if (current && typeof current === "object" && part in current) {
          current = current[part];
        } else {
          return undefined;
        }
      }
      return current;
    }

    function extractor_getSelectedKeys() {
      return Array.from(extractorKeys.querySelectorAll('input[type="checkbox"]:checked'))
        .map(cb => cb.value)
        .sort();
    }

    function extractor_setError(msg) {
      extractorPreview.textContent = msg;
      extractorPreview.style.color = "#fca5a5";
    }

    function extractor_setOk(text) {
      extractorPreview.textContent = text;
      extractorPreview.style.color = "var(--app-text)";
    }

    function extractor_refreshKeys() {
      if (!extractorInput || !extractorKeys) return;
      extractorKeys.innerHTML = "";

      const jsonText = (extractorInput.value || "").trim();
      if (!jsonText) {
        extractor_setOk("Paste a JSON array above to see keys.");
        return;
      }

      try {
        const jsonData = JSON.parse(jsonText);
        if (!Array.isArray(jsonData)) throw new Error("JSON does not contain an array");

        const keySet = new Set();
        jsonData.forEach(item => extractor_collectKeys(item, keySet));
        const keys = Array.from(keySet).sort();

        if (keys.length === 0) {
          extractor_setOk("No object keys found.");
          return;
        }

        keys.forEach(key => {
          const label = document.createElement("label");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = key;
          label.appendChild(checkbox);

          const span = document.createElement("span");
          span.textContent = key;
          label.appendChild(span);

          extractorKeys.appendChild(label);
        });

        extractor_setOk("Select keys and click Extract.");
      } catch (error) {
        extractor_setError(`Error processing JSON: ${error.message}`);
      }
    }

    function extractor_run() {
      const jsonText = (extractorInput.value || "").trim();
      extractorJsonOutput.value = "";

      try {
        const jsonData = JSON.parse(jsonText);
        if (!Array.isArray(jsonData)) throw new Error("JSON does not contain an array");

        const selectedKeys = extractor_getSelectedKeys();
        if (selectedKeys.length === 0) {
          extractor_setOk("No keys selected.");
          return;
        }

        // Preview (original behavior style)
        let preview = "";
        const extracted = [];

        jsonData.forEach((record, index) => {
          preview += `Record ${index + 1}:\n`;
          const outObj = {};
          selectedKeys.forEach(key => {
            const value = extractor_getNestedValue(record, key.split('.'));
            if (value !== undefined) {
              preview += `${key}: ${JSON.stringify(value)}\n`;
              outObj[key] = value;
            }
          });
          preview += "\n";
          extracted.push(outObj);
        });

        extractor_setOk(preview.trimEnd());
        extractorJsonOutput.value = JSON.stringify(extracted, null, 2);
      } catch (error) {
        extractor_setError(`Error processing JSON: ${error.message}`);
      }
    }

    function extractor_useEditor(sideKey) {
      const tab = getActiveTab();
      const side = tab[sideKey];
      const json = contentToJSON(side.content);
      if (json === null) return;

      extractorInput.value = JSON.stringify(json, null, 2);
      extractor_refreshKeys();
    }

    function extractor_inject(sideKey) {
      const raw = (extractorJsonOutput.value || "").trim();
      if (!raw) {
        alert("No extracted JSON available yet. Click Extract first.");
        return;
      }

      let parsed;
      try {
        parsed = JSON.parse(raw);
      } catch (e) {
        alert("Extracted output is not valid JSON.");
        return;
      }

      const tab = getActiveTab();
      tab[sideKey].mode = "tree";
      tab[sideKey].content = { json: parsed };

      const editor = sideKey === "left" ? leftEditor : rightEditor;
      editor.updateProps({ content: { json: parsed }, mode: "tree" });

      if (sideKey === "left") {
        leftModeSelect.value = "tree";
      } else {
        rightModeSelect.value = "tree";
      }

      saveState();
    }

    if (btnExtractorRefresh) btnExtractorRefresh.addEventListener("click", extractor_refreshKeys);
    if (btnExtractorRun) btnExtractorRun.addEventListener("click", extractor_run);

    if (btnExtractorUseLeft) btnExtractorUseLeft.addEventListener("click", () => extractor_useEditor("left"));
    if (btnExtractorUseRight) btnExtractorUseRight.addEventListener("click", () => extractor_useEditor("right"));

    if (btnExtractorInjectLeft) btnExtractorInjectLeft.addEventListener("click", () => extractor_inject("left"));
    if (btnExtractorInjectRight) btnExtractorInjectRight.addEventListener("click", () => extractor_inject("right"));

    if (btnExtractorCopy) btnExtractorCopy.addEventListener("click", async () => {
      const text = extractorJsonOutput.value || "";
      if (!text.trim()) return;

      try {
        await navigator.clipboard.writeText(text);
        btnExtractorCopy.textContent = "Copied ‚úÖ";
        setTimeout(() => (btnExtractorCopy.textContent = "Copy extracted JSON"), 1200);
      } catch {
        // Fallback
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        btnExtractorCopy.textContent = "Copied ‚úÖ";
        setTimeout(() => (btnExtractorCopy.textContent = "Copy extracted JSON"), 1200);
      }
    });

    if (extractorInput) {
      extractorInput.addEventListener("blur", extractor_refreshKeys);
    }
  </script>
</body>
</html>
