<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SyncApp ERP API Runner</title>
  <link rel="stylesheet" href="../assets/tool.css" />
  <style>
    .actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap: 12px}
    @media (max-width: 980px){ .grid{grid-template-columns: 1fr} }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      border:1px solid var(--app-border); border-radius:999px;
      padding:6px 10px; background: rgba(2,6,23,.35);
      font-size:12px; color: var(--app-muted);
    }
    .ok{color: rgba(34,197,94,.95)}
    .warn{color: rgba(250,204,21,.95)}
    .bad{color: rgba(248,113,113,.95)}
    textarea.big{min-height: 220px}
    textarea.mid{min-height: 160px}
    button.copied{border-color: rgba(34,197,94,.65)}
    details summary{cursor:pointer}
    .kv{display:grid; grid-template-columns: 1fr 1fr; gap: 10px}
    .kv3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px}
    @media (max-width: 980px){ .kv,.kv3{grid-template-columns: 1fr} }
    .small{font-size:12px}
    .codebox{
      border:1px solid var(--app-border);
      border-radius: 12px;
      background: rgba(2,6,23,.35);
      padding: 10px 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .progress{
      width:100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(148,163,184,.18);
      overflow:hidden;
      border: 1px solid var(--app-border);
    }
    .progress > div{
      height: 100%;
      width: 0%;
      background: rgba(96,165,250,.85);
      transition: width .2s ease;
    }
    .rowline{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .rowline > *{flex: 1}
    .rowline .tight{flex: 0 0 auto}
    .hide{display:none !important}

    /* Collapsible sections */
    .section-head{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .section-head h2{margin:0}
    .section-toggle{
      flex: 0 0 auto;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      line-height: 1;
    }
    .card.collapsed .section-body{display:none}
    .card.collapsed .section-toggle{opacity:.9}

    /* Action combobox (type-to-filter) */
    .combo{position:relative}
    .combo-field{position:relative}
    .combo-field input{padding-right: 40px}
    .combo-btn{
      position:absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 22px;
      height: 22px;
      border: 0;
      border-radius: 8px;
      background: transparent;
      color: var(--app-text);
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:0;
      line-height:1;
      opacity: .95;
    }
    .combo-btn:hover{opacity: 1}
    .combo-pop{
      position:absolute;
      left:0; right:0;
      top: calc(100% + 8px);
      z-index: 50;
      border: 1px solid var(--app-border);
      border-radius: 14px;
      background: rgba(2,6,23,.92);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      padding: 10px 12px;
    }
    .combo-list{max-height: 260px; overflow:auto; margin-top:8px}
    .combo-item{
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      user-select:none;
    }
    .combo-item:hover{background: rgba(148,163,184,.12)}

    /* CSV drag & drop */
    .dropzone{
      border: 1px dashed rgba(148,163,184,.35);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(2,6,23,.22);
      transition: border-color .15s ease, background .15s ease;
    }
    .dropzone.dragover{
      border-color: rgba(96,165,250,.85);
      background: rgba(96,165,250,.10);
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="card">
      <div class="page-head">
        <div>
          <h1>SyncApp ERP API Runner</h1>
          <div class="page-sub">
            Run SyncApp ERP APIs (NetSuite / Intacct / QBO) with a bearer token — single-run or runner mode (CSV/paste).
            <span class="muted">Token is not stored unless you explicitly opt in.</span>
          </div>
        </div>
        <div class="page-actions">
          <button id="btnExpandAll" class="secondary" type="button">Expand all</button>
          <button id="btnCollapseAll" class="secondary" type="button">Collapse all</button>
          <button id="btnClearAll" class="secondary" type="button">Clear</button>
        </div>
      </div>
    </div>

    <div class="card" data-section="auth">
      <div class="section-head">
        <h2>1) Auth & Environment</h2>
        <button class="secondary section-toggle" type="button" data-toggle="auth">Collapse</button>
      </div>
      <div class="section-body">
        <div class="muted">
          Paste a bearer token (no client credentials). The tool will call <code>https://syncapp-{erp}.{env}.tipalti.com</code>.
        </div>

        <div class="grid" style="margin-top:10px">
          <div>
            <label for="environment">Environment</label>
            <select id="environment">
              <option value="sbox" selected>Sandbox (sbox)</option>
              <option value="production">Production</option>
            </select>
          </div>
          <div>
            <label for="erp">ERP</label>
            <select id="erp">
              <option value="netsuite">NetSuite</option>
              <option value="intacct">Intacct</option>
              <option value="qbo">QBO</option>
              <option value="custom">Custom API</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <div>
            <label for="payerPublicId">payerPublicId</label>
            <input id="payerPublicId" type="text" placeholder="e.g. 15662529128510426779030000" />
            <div class="muted small" style="margin-top:6px">
              Used automatically for endpoints that include <code>{payerPublicId}</code>. Runner mode can override per iteration.
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <div>
            <label for="bearerToken">Bearer token</label>
            <input id="bearerToken" type="password" placeholder="Paste token (not saved by default)" />
            <div class="rowline small" style="margin-top:10px">
              <label class="tight" style="display:flex; align-items:center; gap:8px; margin:0; color: var(--app-text)">
                <input id="rememberToken" type="checkbox" />
                Remember token (local only)
              </label>
              <button id="btnClearToken" type="button" class="secondary tight">Clear token</button>
              <span id="tokenStatus" class="pill tight">Token: <strong class="warn">missing</strong></span>
            </div>
          </div>
        </div>

        <div class="grid" style="margin-top:10px">
          <div>
            <label for="delayMs">Delay between requests (ms)</label>
            <input id="delayMs" type="number" min="0" step="50" value="1500" />
            <div class="muted small">Tip: keep ≥ 1500ms if you see rate limits.</div>
          </div>
          <div>
            <label for="timeoutMs">Request timeout (ms)</label>
            <input id="timeoutMs" type="number" min="1000" step="500" value="30000" />
          </div>
        </div>

        <hr />

        <h3>Proxy (required for GitHub Pages)</h3>
        <div class="muted">
          Some SyncApp hosts respond with <code>Cross-Origin-Resource-Policy: same-origin</code>, so browser <code>fetch</code> fails with <code>TypeError: Failed to fetch</code>.
          A proxy makes requests server-side and returns the response with permissive CORS.
        </div>

        <div class="row" style="margin-top:10px">
          <div>
            <label class="tight" style="display:flex; align-items:center; gap:8px; margin:0; color: var(--app-text)">
              <input id="useProxy" type="checkbox" />
              Use proxy
            </label>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <div>
            <label for="proxyBaseUrl">Proxy base URL</label>
            <input id="proxyBaseUrl" type="text" placeholder="http://localhost:8787" value="http://localhost:8787" />
            <div class="muted small">
              If you’re using a shared/team proxy, paste its base URL here.
              You can also auto-configure this tool via query params: <code>?useProxy=1&amp;proxyBaseUrl=...</code>
              <br/>If port <code>8787</code> is busy, start the proxy on another port (e.g. <code>PORT=8788 node tools/syncapp-erp-api-proxy.js</code>) and update this field.
              <br/>If this page is served over <strong>HTTPS</strong> (GitHub Pages), the proxy must also be <strong>HTTPS</strong> (or the browser will block it as mixed content).
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card" data-section="action">
      <div class="section-head">
        <h2>2) API request</h2>
        <button class="secondary section-toggle" type="button" data-toggle="action">Collapse</button>
      </div>
      <div class="section-body">
        <div class="muted" id="registryHelp">
          Choose an action from the registry and fill any placeholders. Runner mode can override these values per-iteration.
        </div>

        <div id="customApiWrap" class="hide" style="margin-top:10px">
          <div class="muted">
            Custom API mode lets you run any request. Use <code>{placeholders}</code> in URL/headers/body and override them via runner CSV columns.
            <span class="muted small"><br/>Note: if you enable the proxy, targets are restricted to <code>https://*.tipalti.com</code> for safety.</span>
          </div>

          <div class="grid" style="margin-top:10px">
            <div>
              <label for="customMethod">HTTP method</label>
              <select id="customMethod">
                <option value="GET" selected>GET</option>
                <option value="POST">POST</option>
                <option value="PUT">PUT</option>
                <option value="PATCH">PATCH</option>
                <option value="DELETE">DELETE</option>
              </select>
            </div>
            <div>
              <label class="tight" style="display:flex; align-items:center; gap:8px; margin:24px 0 0; color: var(--app-text)">
                <input id="customIncludeAuth" type="checkbox" checked />
                Add Authorization: Bearer &lt;token&gt;
              </label>
            </div>
          </div>

          <details style="margin-top:10px">
            <summary class="muted">Import from cURL</summary>
            <div class="muted small" style="margin-top:10px">
              Paste a <code>curl</code> command and click Import to populate method, URL, query params, headers, and body.
            </div>
            <label for="customCurl" class="muted small">cURL</label>
            <textarea id="customCurl" class="mono mid" placeholder="curl -X GET 'https://syncapp-netsuite.sbox.tipalti.com/api/v1/credentials?payerPublicId=123' -H 'Authorization: Bearer ...'"></textarea>
            <div class="actions">
              <button id="btnImportCurl" type="button">Import cURL</button>
              <button id="btnClearCurl" type="button" class="secondary">Clear</button>
            </div>
          </details>

          <label for="customUrl">Full URL</label>
          <input id="customUrl" type="text" placeholder="https://example.internal/api/v1/items?x=1" />

          <div style="margin-top:10px">
            <label>Query params (optional)</label>
            <div class="muted small" style="margin-top:6px">
              These are appended to the URL. Values support <code>{placeholders}</code>, and runner columns can override by using the same key name.
            </div>
            <div id="customQpWrap" class="codebox" style="margin-top:8px">
              <div id="customQpRows"></div>
              <div class="actions" style="margin-top:8px">
                <button id="btnCustomAddQp" type="button" class="secondary">Add query param</button>
              </div>
            </div>
          </div>

          <div class="grid" style="margin-top:10px">
            <div>
              <label for="customHeaders">Headers (JSON object or Key: Value per line)</label>
              <textarea id="customHeaders" class="mono mid" placeholder="{&quot;accept&quot;:&quot;application/json&quot;}"></textarea>
            </div>
            <div>
              <label for="customBody">Body (optional)</label>
              <textarea id="customBody" class="mono mid" placeholder="{&quot;example&quot;:true}"></textarea>
              <div class="muted small" style="margin-top:6px">
                For GET requests, body will be ignored by most servers.
              </div>
            </div>
          </div>
        </div>

      <div id="registryWrap">
        <label style="margin-top:10px">Action</label>
        <div id="actionCombo" class="combo" style="margin-top:8px">
          <div class="combo-field">
            <input id="actionComboInput" type="text" placeholder="Select an action…" autocomplete="off" />
            <button id="actionComboBtn" type="button" class="combo-btn" aria-label="Open actions">▾</button>
          </div>
          <div id="actionComboPop" class="combo-pop hide">
            <div id="actionComboList" class="combo-list"></div>
          </div>
        </div>
        <!-- keep the select for internal compatibility -->
        <select id="actionSelect" class="hide" aria-hidden="true" tabindex="-1"></select>

        <div id="pathParamsCard" style="margin-top:10px">
          <h3 style="margin-top:12px">Path parameters</h3>
          <div id="pathParams" class="grid"></div>
          <div class="muted small" style="margin-top:8px">
            Runner mode can override these by providing columns named like the placeholders (e.g. <code>payerPublicId</code>, <code>id</code>, <code>recordType</code>).
          </div>
        </div>

        <hr />

        <div id="queryParamsWrap">
          <h3>Query parameters (optional)</h3>
          <div class="muted">
            These will be appended as query params if present. Runner mode can override them per row.
          </div>

          <div class="kv3" style="margin-top:10px">
            <div>
              <label for="qpSearchId">searchId</label>
              <input id="qpSearchId" type="text" placeholder="e.g. 12345" />
            </div>
            <div>
              <label for="qpPageIndex">pageIndex</label>
              <input id="qpPageIndex" type="number" step="1" placeholder="e.g. 0" />
            </div>
            <div>
              <label for="qpPageSize">pageSize</label>
              <input id="qpPageSize" type="number" step="1" placeholder="e.g. 200" />
            </div>
          </div>

          <div class="kv" style="margin-top:10px">
            <div>
              <label for="qpFetchAll">fetchAll</label>
              <select id="qpFetchAll">
                <option value="" selected>(unset)</option>
                <option value="true">true</option>
                <option value="false">false</option>
              </select>
            </div>
            <div>
              <label for="qpWhere">where</label>
              <input id="qpWhere" type="text" placeholder="e.g. status='ACTIVE' AND updatedAt&gt;='2025-01-01'" />
            </div>
          </div>
        </div>
      </div>

      <hr style="margin-top:14px" />
      <label style="margin-top:10px">URL preview</label>
      <div id="urlPreview" class="codebox mono">(select an action or enter a Custom URL)</div>
      </div>
    </div>

    <div class="card" data-section="runner">
      <div class="section-head">
        <h2>3) Runner (Postman-style)</h2>
        <button class="secondary section-toggle" type="button" data-toggle="runner">Collapse</button>
      </div>
      <div class="section-body">
        <div class="muted">
          Run the selected action multiple times by iterating variables from a CSV (columns = variables) or a pasted list (single variable).
        </div>

      <div class="row" style="margin-top:10px">
        <label class="tight" style="display:flex; align-items:center; gap:8px; margin:0; color: var(--app-text)">
          <input id="runnerEnabled" type="checkbox" />
          Enable runner mode
        </label>
        <span class="pill tight">Iterations: <strong id="iterationCount">0</strong></span>
        <span class="pill tight">Completed: <strong id="completedCount">0</strong></span>
        <span class="pill tight">Failed: <strong id="failedCount">0</strong></span>
      </div>

      <div id="runnerSection" class="hide" style="margin-top:10px">
        <div class="grid">
          <div>
            <label for="runnerMode">Runner input mode</label>
            <select id="runnerMode">
              <option value="singleVar" selected>Single variable list (paste or CSV column)</option>
              <option value="csvRows">CSV rows (each row = variables)</option>
            </select>
            <div class="muted small" style="margin-top:8px">
              Recommended: <strong>CSV rows</strong> if you want to override multiple variables per request.
            </div>
          </div>
          <div id="singleVarConfig">
            <label for="singleVarName">Variable to iterate</label>
            <select id="singleVarName"></select>
            <div class="muted small" style="margin-top:8px">
              This can be any path placeholder (e.g. <code>id</code>) or a query param (<code>pageIndex</code>, <code>searchId</code>, ...).
            </div>
          </div>
        </div>

        <div class="grid" style="margin-top:10px">
          <div>
            <label for="runnerCsvFile">Upload CSV (optional)</label>
            <div id="runnerDropZone" class="dropzone" style="margin-top:8px">
              <div class="muted small">Drag & drop a CSV/TSV here, or use the file picker:</div>
              <div style="margin-top:8px">
                <input id="runnerCsvFile" type="file" accept=".csv,.tsv,.txt" />
              </div>
              <div id="csvHints" class="muted small" style="margin-top:8px"></div>
            </div>
          </div>
          <div id="singleVarColumnWrap">
            <label for="singleVarColumn">CSV column (for single-variable mode)</label>
            <select id="singleVarColumn" disabled></select>
          </div>
        </div>

        <label for="runnerText">Paste runner input</label>
        <div class="muted small" style="margin-top:6px">
          Single-variable mode: paste one value per line (or comma/tab separated).<br/>
          CSV rows mode: paste a full CSV/TSV including the header row (columns = variables).
        </div>
        <textarea id="runnerText" class="mono mid" placeholder="payerId,payeeId&#10;123,456&#10;123,789"></textarea>

        <div id="singleVarTransform" class="grid" style="margin-top:10px">
          <div>
            <label for="singleVarPrefix">Value prefix (optional)</label>
            <input id="singleVarPrefix" type="text" placeholder="e.g. tranId=" />
            <div class="muted small" style="margin-top:6px">
              Prepended to each pasted value in single-variable mode (useful for <code>where</code>).
            </div>
          </div>
          <div>
            <label for="singleVarSuffix">Value suffix (optional)</label>
            <input id="singleVarSuffix" type="text" placeholder="e.g. '  (to close a quote)" />
            <div class="muted small" style="margin-top:6px">
              Appended to each pasted value. Example: prefix <code>tranId='</code> and suffix <code>'</code>.
            </div>
          </div>
        </div>

        <div class="actions">
          <button id="btnPasteRunner" type="button" class="secondary">Paste from clipboard</button>
          <button id="btnClearRunner" type="button" class="secondary">Clear runner input</button>
          <button id="btnGenPageIndex" type="button">Generate pageIndex range…</button>
        </div>

        <details style="margin-top:10px">
          <summary class="muted">Show runner CSV format examples</summary>
          <div class="muted small" style="margin-top:10px">
            <div><strong>CSV rows example</strong> (columns become variables):</div>
            <div class="codebox mono" style="margin-top:8px">payerPublicId,recordType,id,pageIndex,pageSize,where
12345,vendor,999,0,200,status='ACTIVE'
12345,vendor,999,1,200,status='ACTIVE'</div>
            <div style="margin-top:10px"><strong>Single variable example</strong> (iterate <code>pageIndex</code>):</div>
            <div class="codebox mono" style="margin-top:8px">0
1
2
3</div>
          </div>
        </details>
      </div>
      </div>
    </div>

    <div class="card" data-section="execute">
      <div class="section-head">
        <h2>4) Execute</h2>
        <button class="secondary section-toggle" type="button" data-toggle="execute">Collapse</button>
      </div>
      <div class="section-body">
        <div class="muted">
          Single-run executes one request. Runner mode executes multiple requests and aggregates all responses into one JSON.
        </div>

      <div class="actions">
        <button id="btnRunOnce" type="button">Run once</button>
        <button id="btnRunRunner" type="button">Run runner</button>
        <button id="btnStop" type="button" class="secondary" disabled>Stop</button>
        <button id="btnClearResults" type="button" class="secondary">Clear results</button>
      </div>

      <div id="progressWrap" class="hide" style="margin-top:12px">
        <div class="rowline">
          <div class="progress"><div id="progressBar"></div></div>
          <div class="pill tight">Progress: <strong id="progressText">0 / 0</strong></div>
          <div class="pill tight">Status: <strong id="statusText">Ready</strong></div>
        </div>
      </div>

      <details style="margin-top:12px">
        <summary class="muted">Logs</summary>
        <div id="logs" class="codebox mono" style="margin-top:10px; min-height: 120px"></div>
      </details>
      </div>
    </div>

    <div class="card" data-section="output">
      <div class="section-head">
        <h2>5) Aggregated response</h2>
        <button class="secondary section-toggle" type="button" data-toggle="output">Collapse</button>
      </div>
      <div class="section-body">
        <div class="muted">
          The aggregated output is always valid JSON. Use “Copy aggregated JSON” to paste into tickets/tools.
        </div>

      <div class="row" style="margin-top:10px">
        <div>
          <label for="aggMode">Aggregation mode</label>
          <select id="aggMode">
            <option value="full" selected>Full (meta + results)</option>
            <option value="entities">Entities only (flatten body.entities)</option>
          </select>
          <div class="muted small" style="margin-top:6px">
            “Entities only” outputs a JSON array containing only <code>body.entities</code> from each successful response.
          </div>
        </div>
      </div>

      <div class="actions">
        <button id="btnCopyAgg" type="button">Copy aggregated JSON</button>
        <button id="btnDownloadAgg" type="button" class="secondary">Download JSON</button>
      </div>

      <label for="aggOut">Aggregated JSON</label>
      <textarea id="aggOut" class="mono big" placeholder="{ ... }"></textarea>
      </div>
    </div>

    <footer class="muted" style="margin: 12px 0 0; text-align:center; font-size: 12px">
      SyncApp ERP API Runner · v1.0
    </footer>
  </div>

  <script>
    // ---------------- Registry (ported from CLI script) ---------------------
    const NETSUITE_CLOSED_RECORDS = [
      "account", "accountingPeriod", "bill", "class", "currency", "customer",
      "customList", "customRecordType", "department", "deposit", "employee",
      "entityCustomField", "expenseCategory", "expenseReport", "file", "folder",
      "item", "itemFulfillment", "itemReceipt", "location", "payment",
      "paymentTerm", "project", "purchaseOrder", "salesOrder", "SalesTaxItem",
      "state", "subsidiary", "tax-codes", "tax-rates", "transactionBodyCustomField",
      "transactionColumnCustomField", "unit", "vendor", "vendorCredit",
      "vendorSubsidiaryRelationship"
    ];

    // Order: NetSuite, Intacct, QBO
    const MASTER_REGISTRY = {
      netsuite: {
        "1": { name: "RecordTypes", path: "/api/v1/resources/{recordType}/{id}?payerPublicId={payerPublicId}", method: "GET" },
        "2": { name: "PayerCredentials", path: "/api/v1/credentials?payerPublicId={payerPublicId}", method: "GET" },
        "3": { name: "Custom Record", path: "/api/v1/resources/{recordType}/{id}/custom-records?payerPublicId={payerPublicId}", method: "GET" },
        "4": { name: "CustomizationId", path: "/api/v1/resources/customizationId/{recordType}?payerPublicId={payerPublicId}", method: "GET" }
      },
      intacct: {
        "1": { name: "Accounts", path: "/api/intacct/payers/{payerPublicId}/recordTypes/accounts/{id}", method: "GET" },
        "2": { name: "Audits", path: "/api/intacct/payers/{payerPublicId}/recordTypes/audits/{id}", method: "GET" },
        "3": { name: "BankAccounts", path: "/api/intacct/payers/{payerPublicId}/recordTypes/bank-accounts/{id}", method: "GET" },
        "4": { name: "Bills", path: "/api/intacct/payers/{payerPublicId}/recordTypes/bills/{id}", method: "GET" },
        "5": { name: "BillsAdvanced", path: "/api/intacct/payers/{payerPublicId}/recordTypes/bills-advanced/{id}", method: "GET" },
        "6": { name: "Classes", path: "/api/intacct/payers/{payerPublicId}/recordTypes/classes/{id}", method: "GET" },
        "7": { name: "ClassesExtended", path: "/api/intacct/payers/{payerPublicId}/recordTypes/classes-extended/{id}", method: "GET" },
        "8": { name: "Credentials", path: "/api/intacct/payers/{payerPublicId}/recordTypes/credentials", method: "GET" },
        "9": { name: "CreditCards", path: "/api/intacct/payers/{payerPublicId}/recordTypes/credit-cards/{id}", method: "GET" },
        "10": { name: "Customers", path: "/api/intacct/payers/{payerPublicId}/recordTypes/customers/{id}", method: "GET" },
        "11": { name: "Definitions", path: "/api/intacct/payers/{payerPublicId}/recordTypes/definitions/{id}", method: "GET" },
        "12": { name: "Departments", path: "/api/intacct/payers/{payerPublicId}/recordTypes/departments/{id}", method: "GET" },
        "13": { name: "Deposits", path: "/api/intacct/payers/{payerPublicId}/recordTypes/deposits/{id}", method: "GET" },
        "14": { name: "Dimensions", path: "/api/intacct/payers/{payerPublicId}/recordTypes/dimensions/{id}", method: "GET" },
        "15": { name: "Employees", path: "/api/intacct/payers/{payerPublicId}/recordTypes/employees/{id}", method: "GET" },
        "16": { name: "Files", path: "/api/intacct/payers/{payerPublicId}/recordTypes/files/{id}", method: "GET" },
        "17": { name: "Folders", path: "/api/intacct/payers/{payerPublicId}/recordTypes/folders/{folderName}", method: "GET" },
        "18": { name: "ItemReceipts", path: "/api/intacct/payers/{payerPublicId}/recordTypes/item-receipts/{id}", method: "GET" },
        "19": { name: "Items", path: "/api/intacct/payers/{payerPublicId}/recordTypes/items/{id}", method: "GET" },
        "20": { name: "LedgerDetails", path: "/api/intacct/payers/{payerPublicId}/recordTypes/ledger-details/{id}", method: "GET" },
        "21": { name: "Locations", path: "/api/intacct/payers/{payerPublicId}/recordTypes/locations/{id}", method: "GET" },
        "22": { name: "Lookup", path: "/api/intacct/payers/{payerPublicId}/recordTypes/lookup/{item}", method: "GET" },
        "23": { name: "Payments", path: "/api/intacct/payers/{payerPublicId}/recordTypes/payments/{id}", method: "GET" },
        "24": { name: "PaymentTerms", path: "/api/intacct/payers/{payerPublicId}/recordTypes/payment-terms/{id}", method: "GET" },
        "25": { name: "Projects", path: "/api/intacct/payers/{payerPublicId}/recordTypes/projects/{id}", method: "GET" },
        "26": { name: "ProjectsAdvanced", path: "/api/intacct/payers/{payerPublicId}/recordTypes/projects-advanced/{id}", method: "GET" },
        "27": { name: "PurchaseOrders", path: "/api/intacct/payers/{payerPublicId}/recordTypes/purchase-orders/{id}", method: "GET" },
        "28": { name: "PurchaseOrdersAdvanced", path: "/api/intacct/payers/{payerPublicId}/recordTypes/purchase-orders-advanced/{id}", method: "GET" },
        "29": { name: "Subsidiaries", path: "/api/intacct/payers/{payerPublicId}/recordTypes/subsidiaries/{id}", method: "GET" },
        "30": { name: "TaxCodes", path: "/api/intacct/payers/{payerPublicId}/recordTypes/tax-codes/{id}", method: "GET" },
        "31": { name: "Units", path: "/api/intacct/payers/{payerPublicId}/recordTypes/units/{id}", method: "GET" },
        "32": { name: "VendorCredits", path: "/api/intacct/payers/{payerPublicId}/recordTypes/vendor-credits/{id}", method: "GET" },
        "33": { name: "VendorCreditsAdvanced", path: "/api/intacct/payers/{payerPublicId}/recordTypes/vendor-credits-advanced/{id}", method: "GET" },
        "34": { name: "Vendors", path: "/api/intacct/payers/{payerPublicId}/recordTypes/vendors/{id}", method: "GET" },
        "35": { name: "Warehouses", path: "/api/intacct/payers/{payerPublicId}/recordTypes/warehouses/{id}", method: "GET" }
      },
      qbo: {
        "1": { name: "Accounts", path: "/api/qbo/payers/{payerPublicId}/accounts/{id}", method: "GET" },
        "2": { name: "BillPayments", path: "/api/qbo/payers/{payerPublicId}/bill-payments/{id}", method: "GET" },
        "3": { name: "Bills", path: "/api/qbo/payers/{payerPublicId}/bills/{id}", method: "GET" },
        "4": { name: "Classes", path: "/api/qbo/payers/{payerPublicId}/classes/{id}", method: "GET" },
        "5": { name: "CompanyInfos", path: "/api/qbo/payers/{payerPublicId}/company-infos/{id}", method: "GET" },
        "6": { name: "Currencies", path: "/api/qbo/payers/{payerPublicId}/currencies/{id}", method: "GET" },
        "7": { name: "Customers", path: "/api/qbo/payers/{payerPublicId}/customers/{id}", method: "GET" },
        "8": { name: "Departments", path: "/api/qbo/payers/{payerPublicId}/departments/{id}", method: "GET" },
        "9": { name: "Deposits", path: "/api/qbo/payers/{payerPublicId}/deposits/{id}", method: "GET" },
        "10": { name: "ExchangeRates", path: "/api/qbo/payers/{payerPublicId}/exchange-rates/{id}", method: "GET" },
        "11": { name: "MetaData", path: "/api/qbo/payers/{payerPublicId}/metadata/{objectName}", method: "GET" },
        "12": { name: "PaymentsTerms", path: "/api/qbo/payers/{payerPublicId}/payment-terms/{id}", method: "GET" },
        "13": { name: "Preferences", path: "/api/qbo/payers/{payerPublicId}/preferences/{id}", method: "GET" },
        "14": { name: "TaxCodes", path: "/api/qbo/payers/{payerPublicId}/tax-codes/{id}", method: "GET" },
        "15": { name: "TaxRates", path: "/api/qbo/payers/{payerPublicId}/tax-rates/{id}", method: "GET" },
        "16": { name: "VendorCredits", path: "/api/qbo/payers/{payerPublicId}/vendor-credits/{id}", method: "GET" },
        "17": { name: "Vendors", path: "/api/qbo/payers/{payerPublicId}/vendors/{id}", method: "GET" }
      }
    };

    // ---------------- Helpers ----------------------------------------------
    const STORAGE_KEY = 'syncapp_erp_api_runner_v1';
    let savedActionKey = null;

    const $ = (id) => document.getElementById(id);
    function nowIso() { return new Date().toISOString(); }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ---------------- Custom API query params ------------------------------
    // rows: [{ k: string, v: string }]
    let customQpRows = [{ k: '', v: '' }];

    function getCustomQpRows() {
      return Array.isArray(customQpRows) ? customQpRows : [{ k: '', v: '' }];
    }

    function renderCustomQpRows() {
      const wrap = $('customQpRows');
      if (!wrap) return;
      wrap.innerHTML = '';
      const rows = getCustomQpRows();

      rows.forEach((row, idx) => {
        const line = document.createElement('div');
        line.className = 'rowline';
        line.style.marginTop = idx === 0 ? '0' : '6px';

        const k = document.createElement('input');
        k.type = 'text';
        k.placeholder = 'key (e.g. pageSize)';
        k.value = String(row.k ?? '');
        k.addEventListener('input', () => {
          customQpRows[idx].k = k.value;
          updateUrlPreview();
          saveState();
        });

        const v = document.createElement('input');
        v.type = 'text';
        v.placeholder = 'value (supports {placeholders})';
        v.value = String(row.v ?? '');
        v.addEventListener('input', () => {
          customQpRows[idx].v = v.value;
          updateUrlPreview();
          saveState();
        });

        const del = document.createElement('button');
        del.type = 'button';
        del.className = 'secondary tight';
        del.textContent = 'Remove';
        del.addEventListener('click', () => {
          customQpRows.splice(idx, 1);
          if (!customQpRows.length) customQpRows.push({ k: '', v: '' });
          renderCustomQpRows();
          updateUrlPreview();
          saveState();
        });

        line.appendChild(k);
        line.appendChild(v);
        line.appendChild(del);
        wrap.appendChild(line);
      });
    }

    function safeJsonStringify(obj) {
      try { return JSON.stringify(obj, null, 2); }
      catch (e) { return JSON.stringify({ error: 'Failed to stringify', message: String(e) }, null, 2); }
    }

    function getAggregationMode() {
      return $('aggMode')?.value || 'full';
    }

    function computeEntitiesOnly(fullAgg) {
      const out = [];
      const results = (fullAgg && Array.isArray(fullAgg.results)) ? fullAgg.results : [];
      for (const r of results) {
        const entities = r && r.body && Array.isArray(r.body.entities) ? r.body.entities : null;
        if (entities && entities.length) out.push(...entities);
      }
      return out;
    }

    function refreshAggregatedOutput() {
      if (!aggregated) {
        $('aggOut').value = '';
        return;
      }
      const mode = getAggregationMode();
      if (mode === 'entities') {
        $('aggOut').value = safeJsonStringify(computeEntitiesOnly(aggregated));
      } else {
        $('aggOut').value = safeJsonStringify(aggregated);
      }
    }

    function addLog(line) {
      const logs = $('logs');
      const ts = new Date().toLocaleTimeString();
      logs.textContent += `[${ts}] ${line}\n`;
      logs.scrollTop = logs.scrollHeight;
    }

    function clearLogs() { $('logs').textContent = ''; }

    function parseList(raw) {
      if (!raw) return [];
      const parts = String(raw).split(/[\n,;\t|\r]+/g);
      const cleaned = parts.map(x => String(x).trim()).filter(Boolean);
      return cleaned;
    }

    function detectDelimiter(line) {
      const s = String(line || '');
      const counts = [
        { d: ',', c: (s.match(/,/g) || []).length },
        { d: ';', c: (s.match(/;/g) || []).length },
        { d: '\t', c: (s.match(/\t/g) || []).length },
        { d: '|', c: (s.match(/\|/g) || []).length },
      ].sort((a,b) => b.c - a.c);
      return counts[0].c > 0 ? counts[0].d : ',';
    }

    // Basic CSV/TSV line parsing with quotes.
    function parseDelimitedLine(line, delimiter) {
      const out = [];
      let cur = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
          else inQuotes = !inQuotes;
          continue;
        }
        if (!inQuotes && ch === delimiter) { out.push(cur); cur = ''; continue; }
        cur += ch;
      }
      out.push(cur);
      return out.map(x => x.trim());
    }

    function parseDelimitedTable(text) {
      const lines = String(text || '')
        .split(/\r?\n/)
        .map(l => l.replace(/\r/g, ''))
        .filter(l => l.trim().length > 0);
      if (!lines.length) return { headers: [], rows: [] };
      const delimiter = detectDelimiter(lines[0]);
      const headers = parseDelimitedLine(lines[0], delimiter).map(h => h.replace(/^"|"$/g, '').trim());
      const rows = [];
      for (let i = 1; i < lines.length; i++) {
        const values = parseDelimitedLine(lines[i], delimiter);
        const obj = {};
        for (let j = 0; j < headers.length; j++) obj[headers[j]] = values[j] ?? '';
        rows.push(obj);
      }
      return { headers, rows, delimiter };
    }

    function normalizeKey(s) {
      return String(s ?? '').trim().toLowerCase().replace(/\s+/g, '');
    }

    function collectQueryParamsFromUi() {
      const qp = {};
      const searchId = $('qpSearchId').value.trim();
      const pageIndex = $('qpPageIndex').value.trim();
      const pageSize = $('qpPageSize').value.trim();
      const fetchAll = $('qpFetchAll').value.trim();
      const where = $('qpWhere').value.trim();

      if (searchId) qp.searchId = searchId;
      if (pageIndex !== '') qp.pageIndex = pageIndex;
      if (pageSize !== '') qp.pageSize = pageSize;
      if (fetchAll) qp.fetchAll = fetchAll;
      if (where) qp.where = where;
      return qp;
    }

    function buildBaseHost(erp, env) {
      return `https://syncapp-${erp}.${env}.tipalti.com`;
    }

    function getSelectedAction() {
      const erp = $('erp').value;
      if (erp === 'custom') {
        return { erp: 'custom', key: 'custom', name: 'Custom API', method: $('customMethod').value, path: '' };
      }
      const key = $('actionSelect').value;
      const action = MASTER_REGISTRY[erp]?.[key];
      if (!action) return null;
      return { erp, key, ...action };
    }

    function extractPlaceholders(path) {
      const re = /\{(.*?)\}/g;
      const out = [];
      let m;
      while ((m = re.exec(path)) !== null) out.push(m[1]);
      return [...new Set(out)];
    }

    function applyTemplate(str, vars) {
      const s = String(str ?? '');
      return s.replace(/\{(.*?)\}/g, (_, k) => {
        const key = String(k ?? '').trim();
        if (!key) return `{${k}}`;
        if (!Object.prototype.hasOwnProperty.call(vars || {}, key)) return `{${k}}`;
        const v = vars[key];
        if (v === undefined || v === null) return '';
        return String(v);
      });
    }

    function parseHeadersInput(raw) {
      const txt = String(raw ?? '').trim();
      if (!txt) return {};
      // JSON object
      if (txt.startsWith('{')) {
        try {
          const obj = JSON.parse(txt);
          if (obj && typeof obj === 'object' && !Array.isArray(obj)) return obj;
        } catch {}
      }
      // Key: Value per line
      const out = {};
      for (const line of txt.split(/\r?\n/)) {
        const t = line.trim();
        if (!t) continue;
        const idx = t.indexOf(':');
        if (idx <= 0) continue;
        const k = t.slice(0, idx).trim();
        const v = t.slice(idx + 1).trim();
        if (!k) continue;
        out[k] = v;
      }
      return out;
    }

    function headersToText(headersObj) {
      const obj = headersObj && typeof headersObj === 'object' ? headersObj : {};
      const lines = [];
      for (const [k, v] of Object.entries(obj)) {
        if (v === undefined || v === null || String(v).trim() === '') continue;
        lines.push(`${k}: ${String(v)}`);
      }
      return lines.join('\n');
    }

    function tokenizeCommandLine(str) {
      // Very small tokenizer that handles quotes/backslashes enough for typical copied cURL.
      const s = String(str || '').trim();
      const out = [];
      let cur = '';
      let quote = null; // "'" | '"'
      for (let i = 0; i < s.length; i++) {
        const ch = s[i];
        if (quote) {
          if (ch === quote) { quote = null; continue; }
          if (quote === '"' && ch === '\\' && i + 1 < s.length) {
            // allow basic escapes inside double quotes
            cur += s[i + 1];
            i++;
            continue;
          }
          cur += ch;
          continue;
        }
        if (ch === '"' || ch === "'") { quote = ch; continue; }
        if (ch === '\\' && i + 1 < s.length) {
          // line continuation or escaped char
          const next = s[i + 1];
          if (next === '\n' || next === '\r') { i++; continue; }
          cur += next;
          i++;
          continue;
        }
        if (/\s/.test(ch)) {
          if (cur) { out.push(cur); cur = ''; }
          continue;
        }
        cur += ch;
      }
      if (cur) out.push(cur);
      return out;
    }

    function parseCurlCommand(raw) {
      const tokens = tokenizeCommandLine(raw);
      if (!tokens.length) return { ok: false, error: 'Empty cURL' };
      if (!/^curl(\.exe)?$/i.test(tokens[0])) return { ok: false, error: 'Not a cURL command (must start with curl)' };

      let method = '';
      let url = '';
      const headers = {};
      const dataParts = [];

      for (let i = 1; i < tokens.length; i++) {
        const t = tokens[i];
        const next = tokens[i + 1];

        // URL forms
        if (t === '--url' && next) { url = next; i++; continue; }

        // method
        if ((t === '-X' || t === '--request') && next) { method = next; i++; continue; }

        // headers
        if ((t === '-H' || t === '--header') && next) {
          const line = String(next);
          const idx = line.indexOf(':');
          if (idx > 0) {
            const k = line.slice(0, idx).trim();
            const v = line.slice(idx + 1).trim();
            if (k) headers[k] = v;
          }
          i++;
          continue;
        }

        // data/body
        if ((t === '-d' || t === '--data' || t === '--data-raw' || t === '--data-binary' || t === '--data-urlencode') && next !== undefined) {
          dataParts.push(String(next));
          i++;
          continue;
        }

        // ignore common flags with args
        if ((t === '-u' || t === '--user' || t === '--compressed' || t === '-k' || t === '--insecure' || t === '-s' || t === '--silent')) {
          if ((t === '-u' || t === '--user') && next) i++;
          continue;
        }

        // first bare token that looks like a URL
        if (!t.startsWith('-') && !url && /^https?:\/\//i.test(t)) {
          url = t;
          continue;
        }
      }

      const body = dataParts.length ? dataParts.join('&') : '';
      if (!method) method = body ? 'POST' : 'GET';
      if (!url) return { ok: false, error: 'No URL found in cURL' };
      return { ok: true, method: method.toUpperCase(), url, headers, body };
    }

    function importCurlToCustomApi() {
      const raw = $('customCurl').value || '';
      const parsed = parseCurlCommand(raw);
      if (!parsed.ok) { alert(`Import failed: ${parsed.error}`); return; }

      // switch to custom mode (but don't change env)
      $('erp').value = 'custom';
      renderActionOptions();

      $('customMethod').value = parsed.method || 'GET';

      // Split URL query into builder rows
      const u = safeParseUrl(parsed.url);
      if (u) {
        $('customUrl').value = `${u.origin}${u.pathname}`;
        const rows = [];
        for (const [k, v] of u.searchParams.entries()) rows.push({ k, v });
        customQpRows = rows.length ? rows : [{ k: '', v: '' }];
        renderCustomQpRows();
      } else {
        $('customUrl').value = parsed.url;
        customQpRows = [{ k: '', v: '' }];
        renderCustomQpRows();
      }

      // Authorization handling
      const hdrsLower = {};
      for (const [k, v] of Object.entries(parsed.headers || {})) hdrsLower[String(k).toLowerCase()] = v;
      const auth = hdrsLower['authorization'];
      if (auth && /^bearer\s+/i.test(auth)) {
        const tok = auth.replace(/^bearer\s+/i, '').trim();
        if (tok) $('bearerToken').value = tok;
        $('customIncludeAuth').checked = true;
        // remove auth header from custom headers to avoid duplicates
        const headersNoAuth = { ...(parsed.headers || {}) };
        for (const k of Object.keys(headersNoAuth)) {
          if (String(k).toLowerCase() === 'authorization') delete headersNoAuth[k];
        }
        $('customHeaders').value = headersToText(headersNoAuth);
      } else {
        // keep whatever auth user provided in headers, and don't force includeAuth
        $('customHeaders').value = headersToText(parsed.headers || {});
      }

      // Body
      $('customBody').value = parsed.body || '';

      // refresh UI
      setTokenStatus();
      renderSingleVarCandidates();
      updateUrlPreview();
      saveState();
    }

    function safeParseUrl(raw) {
      try { return new URL(String(raw)); } catch { return null; }
    }

    function getCustomQpRows() {
      // rows: [{k, v}]
      try { return customQpRows || []; } catch { return []; }
    }

    function normalizeQpKey(k) {
      return String(k ?? '').trim();
    }

    function buildCustomUrl({ baseUrl, vars, qpRows }) {
      const urlStr = applyTemplate(String(baseUrl || '').trim(), vars || {});
      const u = safeParseUrl(urlStr);
      if (!u) return urlStr;
      for (const row of (qpRows || [])) {
        const key = normalizeQpKey(row.k);
        if (!key) continue;
        const override = (vars && Object.prototype.hasOwnProperty.call(vars, key)) ? vars[key] : undefined;
        const rawVal = override !== undefined ? String(override) : String(row.v ?? '');
        const val = applyTemplate(rawVal, vars || {});
        if (val === '') u.searchParams.delete(key);
        else u.searchParams.set(key, val);
      }
      return u.toString();
    }

    function getPathParamValue(name) {
      const el = document.querySelector(`[data-param="${CSS.escape(name)}"]`);
      return el ? String(el.value ?? '').trim() : '';
    }

    function resolvePathTemplate(action, vars) {
      let path = action.path;
      const placeholders = extractPlaceholders(path);
      for (const p of placeholders) {
        const v = vars[p];
        if (v === undefined || v === null) continue;
        path = path.replaceAll(`{${p}}`, String(v));
      }

      // Special behavior: {id} blank means "ALL" (remove /{id})
      // If any placeholder is still unresolved, we leave it as-is (preview will show it).
      return path;
    }

    function applyIdBlankRemoval(rawPathTemplate, resolvedPath, vars) {
      // Only apply if the *template* had {id} and the provided value is blank.
      if (!rawPathTemplate.includes('{id}')) return resolvedPath;
      const idVal = vars.id;
      if (typeof idVal === 'string' && idVal.trim() === '') {
        return resolvedPath
          .replace('/{id}', '') // if still unresolved
          .replaceAll('/' + encodeURIComponent('{id}'), '')
          .replaceAll('/{id}', '')
          .replaceAll('{id}', '')
          // if we ended up with "/?x=y" (because id was blank), normalize to "?x=y"
          .replace('/?', '?');
      }
      return resolvedPath;
    }

    function buildFinalUrl({ action, env, baseVars, runnerVars }) {
      const erp = action.erp;
      if (erp === 'custom') return '';
      const host = buildBaseHost(erp, env);

      // Variables precedence: runnerVars > baseVars
      const vars = { ...baseVars, ...(runnerVars || {}) };

      // QBO specific formatting for {id}: append |0 if id present and non-empty
      if (erp === 'qbo' && typeof vars.id === 'string' && vars.id.trim()) {
        if (!vars.id.includes('|')) vars.id = `${vars.id}|0`;
      }

      let resolved = resolvePathTemplate(action, vars);
      resolved = applyIdBlankRemoval(action.path, resolved, vars);

      // Query params: merge UI + runner overrides (runner wins)
      const qpUi = collectQueryParamsFromUi();
      const qpRunner = {};

      // Allow runner to set: searchId, pageIndex, fetchAll, pageSize, where
      for (const k of ['searchId', 'pageIndex', 'fetchAll', 'pageSize', 'where']) {
        const rv = vars[k];
        if (rv !== undefined && rv !== null && String(rv).trim() !== '') qpRunner[k] = String(rv).trim();
      }

      const qp = { ...qpUi, ...qpRunner };

      // If path already includes ?, we should append with &
      const u = new URL(host + resolved);
      for (const [k, v] of Object.entries(qp)) {
        u.searchParams.set(k, v);
      }
      return u.toString();
    }

    function getBaseVarsFromUi(action) {
      const vars = {};
      if (action.erp === 'custom') {
        vars.payerPublicId = $('payerPublicId').value.trim();
        vars.environment = $('environment').value;
        vars.erp = $('erp').value;
        return vars;
      }
      const placeholders = extractPlaceholders(action.path);
      for (const p of placeholders) {
        if (p === 'payerPublicId') vars[p] = $('payerPublicId').value.trim();
        else vars[p] = getPathParamValue(p);
      }
      return vars;
    }

    function setTokenStatus() {
      const tok = $('bearerToken').value.trim();
      const el = $('tokenStatus');
      if (!tok) {
        el.innerHTML = 'Token: <strong class="warn">missing</strong>';
      } else {
        el.innerHTML = 'Token: <strong class="ok">set</strong>';
      }
    }

    function saveState() {
      const remember = $('rememberToken').checked;
      const s = {
        environment: $('environment').value,
        erp: $('erp').value,
        action: $('actionSelect').value,
        payerPublicId: $('payerPublicId').value,
        delayMs: $('delayMs').value,
        timeoutMs: $('timeoutMs').value,
        useProxy: $('useProxy').checked,
        proxyBaseUrl: $('proxyBaseUrl').value,
        qpSearchId: $('qpSearchId').value,
        qpPageIndex: $('qpPageIndex').value,
        qpPageSize: $('qpPageSize').value,
        qpFetchAll: $('qpFetchAll').value,
        qpWhere: $('qpWhere').value,
        customMethod: $('customMethod')?.value ?? 'GET',
        customIncludeAuth: $('customIncludeAuth')?.checked ?? true,
        customUrl: $('customUrl')?.value ?? '',
        customQpRows: getCustomQpRows(),
        customHeaders: $('customHeaders')?.value ?? '',
        customBody: $('customBody')?.value ?? '',
        runnerEnabled: $('runnerEnabled').checked,
        runnerMode: $('runnerMode').value,
        singleVarName: $('singleVarName').value,
        runnerText: $('runnerText').value,
        singleVarPrefix: $('singleVarPrefix')?.value ?? '',
        singleVarSuffix: $('singleVarSuffix')?.value ?? '',
        rememberToken: remember,
        aggMode: getAggregationMode(),
      };
      if (remember) s.bearerToken = $('bearerToken').value;
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); } catch {}
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const s = JSON.parse(raw);
        if (s.environment) $('environment').value = s.environment;
        if (s.erp) $('erp').value = s.erp;
        if (s.action) savedActionKey = s.action;
        if (s.payerPublicId !== undefined) $('payerPublicId').value = s.payerPublicId;
        if (s.delayMs !== undefined) $('delayMs').value = s.delayMs;
        if (s.timeoutMs !== undefined) $('timeoutMs').value = s.timeoutMs;
        if (typeof s.useProxy === 'boolean') $('useProxy').checked = s.useProxy;
        if (typeof s.proxyBaseUrl === 'string' && s.proxyBaseUrl.trim()) $('proxyBaseUrl').value = s.proxyBaseUrl;
        if (s.qpSearchId !== undefined) $('qpSearchId').value = s.qpSearchId;
        if (s.qpPageIndex !== undefined) $('qpPageIndex').value = s.qpPageIndex;
        if (s.qpPageSize !== undefined) $('qpPageSize').value = s.qpPageSize;
        if (s.qpFetchAll !== undefined) $('qpFetchAll').value = s.qpFetchAll;
        if (s.qpWhere !== undefined) $('qpWhere').value = s.qpWhere;
        if (s.customMethod && $('customMethod')) $('customMethod').value = s.customMethod;
        if (typeof s.customIncludeAuth === 'boolean' && $('customIncludeAuth')) $('customIncludeAuth').checked = s.customIncludeAuth;
        if (typeof s.customUrl === 'string' && $('customUrl')) $('customUrl').value = s.customUrl;
        if (Array.isArray(s.customQpRows)) customQpRows = s.customQpRows.map(r => ({ k: String(r?.k ?? ''), v: String(r?.v ?? '') }));
        if (typeof s.customHeaders === 'string' && $('customHeaders')) $('customHeaders').value = s.customHeaders;
        if (typeof s.customBody === 'string' && $('customBody')) $('customBody').value = s.customBody;
        if (typeof s.runnerEnabled === 'boolean') $('runnerEnabled').checked = s.runnerEnabled;
        if (s.runnerMode) $('runnerMode').value = s.runnerMode;
        if (s.singleVarName) $('singleVarName').value = s.singleVarName;
        if (s.runnerText !== undefined) $('runnerText').value = s.runnerText;
        if (typeof s.singleVarPrefix === 'string' && $('singleVarPrefix')) $('singleVarPrefix').value = s.singleVarPrefix;
        if (typeof s.singleVarSuffix === 'string' && $('singleVarSuffix')) $('singleVarSuffix').value = s.singleVarSuffix;
        if (typeof s.rememberToken === 'boolean') $('rememberToken').checked = s.rememberToken;
        if (s.rememberToken && s.bearerToken) $('bearerToken').value = s.bearerToken;
        if (s.aggMode && $('aggMode')) $('aggMode').value = s.aggMode;
      } catch {}
    }

    function applyUrlConfig() {
      const u = new URL(location.href);
      const sp = u.searchParams;
      const useProxyParam = sp.get('useProxy');
      const proxyBaseUrlParam = sp.get('proxyBaseUrl') || sp.get('proxy');
      if (proxyBaseUrlParam) {
        $('proxyBaseUrl').value = proxyBaseUrlParam;
      }
      if (useProxyParam === '1' || useProxyParam === 'true') {
        $('useProxy').checked = true;
      }
      // If a proxy URL is provided, default to enabled (best UX for shared deployment).
      if (proxyBaseUrlParam && useProxyParam === null) {
        $('useProxy').checked = true;
      }
    }

    function warnIfMixedContentProxy() {
      try {
        if (location.protocol !== 'https:') return;
        const base = String($('proxyBaseUrl').value || '').trim();
        if (!base) return;
        if (base.startsWith('http://')) {
          addLog('Warning: page is HTTPS but proxy is HTTP — browsers will block this (mixed content). Use an HTTPS proxy URL.');
        }
      } catch {}
    }

    // ---------------- UI: Registry rendering -------------------------------
    function renderActionOptions() {
      const erp = $('erp').value;
      // Custom API mode: no registry
      if (erp === 'custom') {
        $('customApiWrap').classList.remove('hide');
        $('registryWrap').classList.add('hide');
        $('registryHelp').classList.add('hide');
        $('pathParamsCard').classList.add('hide');
        renderCustomQpRows();
        renderSingleVarCandidates();
        updateUrlPreview();
        return;
      } else {
        $('customApiWrap').classList.add('hide');
        $('registryWrap').classList.remove('hide');
        $('registryHelp').classList.remove('hide');
      }
      const reg = MASTER_REGISTRY[erp] || {};
      const keys = Object.keys(reg).sort((a,b) => Number(a) - Number(b));

      const sel = $('actionSelect');
      const prev = sel.value;
      sel.innerHTML = '';
      for (const k of keys) {
        const item = reg[k];
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = `[${k}] ${item.name}`;
        sel.appendChild(opt);
      }
      // restore selection if possible
      if (prev && [...sel.options].some(o => o.value === prev)) sel.value = prev;
      else if (sel.options.length) sel.value = sel.options[0].value;

      // keep combobox display in sync
      syncActionComboDisplay();
    }

    function renderPathParams() {
      const action = getSelectedAction();
      if (!action) return;

      if (action.erp === 'custom') {
        $('pathParamsCard').classList.add('hide');
        updateUrlPreview();
        return;
      }

      const placeholders = extractPlaceholders(action.path);
      const wrap = $('pathParams');
      wrap.innerHTML = '';

      if (!placeholders.length) {
        $('pathParamsCard').classList.add('hide');
      } else {
        $('pathParamsCard').classList.remove('hide');
      }

      for (const p of placeholders) {
        if (p === 'payerPublicId') continue; // moved to Auth & Environment section
        const div = document.createElement('div');

        const label = document.createElement('label');
        label.textContent = p;
        label.setAttribute('for', `param_${p}`);
        div.appendChild(label);

        // Special: recordType for NetSuite action 1 -> searchable dropdown
        if (p === 'recordType' && action.erp === 'netsuite' && action.key === '1') {
          const combo = document.createElement('div');
          combo.className = 'combo';

          const field = document.createElement('div');
          field.className = 'combo-field';

          const input = document.createElement('input');
          input.id = `param_${p}`;
          input.dataset.param = p;
          input.type = 'text';
          input.placeholder = '(select recordType)';

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'combo-btn';
          btn.setAttribute('aria-label', 'Open recordType');
          btn.textContent = '▾';

          const pop = document.createElement('div');
          pop.className = 'combo-pop hide';

          const list = document.createElement('div');
          list.className = 'combo-list';
          pop.appendChild(list);

          field.appendChild(input);
          field.appendChild(btn);
          combo.appendChild(field);
          combo.appendChild(pop);

          let open = false;
          let hasTyped = false;
          const outsideHandler = (e) => {
            if (!open) return;
            if (combo.contains(e.target)) return;
            close();
          };

          function render() {
            list.innerHTML = '';
            const q = hasTyped ? String(input.value || '').trim().toLowerCase() : '';
            let shown = 0;
            for (const r of NETSUITE_CLOSED_RECORDS) {
              if (q && !String(r).toLowerCase().includes(q)) continue;
              const row = document.createElement('div');
              row.className = 'combo-item';
              row.textContent = r;
              row.addEventListener('click', () => {
                input.value = r;
                hasTyped = false;
                updateUrlPreview();
                saveState();
                close();
              });
              list.appendChild(row);
              shown++;
              if (shown >= 120) break;
            }
            if (shown === 0) {
              const empty = document.createElement('div');
              empty.className = 'muted small';
              empty.textContent = 'No matches';
              list.appendChild(empty);
            }
          }

          function openPop() {
            if (open) return;
            open = true;
            hasTyped = false;
            pop.classList.remove('hide');
            render();
            document.addEventListener('click', outsideHandler);
          }

          function close() {
            if (!open) return;
            open = false;
            pop.classList.add('hide');
            document.removeEventListener('click', outsideHandler);
          }

          btn.addEventListener('click', () => (open ? close() : openPop()));
          input.addEventListener('focus', openPop);
          input.addEventListener('click', openPop);
          input.addEventListener('input', () => {
            hasTyped = true;
            updateUrlPreview();
            saveState();
            if (!open) openPop();
            else render();
          });
          pop.addEventListener('mousedown', (e) => e.preventDefault());

          div.appendChild(combo);
          const hint = document.createElement('div');
          hint.className = 'muted small';
          hint.style.marginTop = '6px';
          hint.textContent = 'NetSuite standard record types list (from the CLI script).';
          div.appendChild(hint);
        } else {
          const input = document.createElement('input');
          input.id = `param_${p}`;
          input.dataset.param = p;
          input.type = (p.toLowerCase() === 'id') ? 'text' : 'text';
          input.placeholder = p.toLowerCase() === 'id' ? 'Leave blank for ALL (if supported)' : `Enter ${p}`;
          input.addEventListener('input', () => { updateUrlPreview(); saveState(); });
          div.appendChild(input);
        }

        wrap.appendChild(div);
      }

      // Refresh single-variable dropdown candidates
      renderSingleVarCandidates();
      updateUrlPreview();
    }

    function renderSingleVarCandidates() {
      const action = getSelectedAction();
      const set = new Set();
      if (action?.erp === 'custom') {
        // derive candidates from templates
        extractPlaceholders($('customUrl').value).forEach(p => set.add(p));
        extractPlaceholders($('customHeaders').value).forEach(p => set.add(p));
        extractPlaceholders($('customBody').value).forEach(p => set.add(p));
      } else if (action) {
        extractPlaceholders(action.path).forEach(p => set.add(p));
      }
      ['searchId','pageIndex','pageSize','fetchAll','where'].forEach(p => set.add(p));
      set.add('payerPublicId');

      const sel = $('singleVarName');
      const prev = sel.value;
      sel.innerHTML = '';
      [...set].sort().forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        sel.appendChild(opt);
      });
      if (prev && [...sel.options].some(o => o.value === prev)) sel.value = prev;
    }

    function updateUrlPreview() {
      const action = getSelectedAction();
      if (!action) return;
      const env = $('environment').value;
      const baseVars = getBaseVarsFromUi(action);
      if (action.erp === 'custom') {
        const vars = { ...baseVars };
        const u0 = $('customUrl').value.trim();
        const url = u0 ? buildCustomUrl({ baseUrl: u0, vars, qpRows: getCustomQpRows() }) : '';
        $('urlPreview').textContent = url || '(enter a Custom URL above)';
      } else {
        const url = buildFinalUrl({ action, env, baseVars, runnerVars: null });
        $('urlPreview').textContent = url;
      }
      saveState();
    }

    // ---------------- Runner parsing --------------------------------------
    let runnerTable = { headers: [], rows: [] }; // from CSV upload

    function setRunnerTable(table, opts = {}) {
      runnerTable = { ...(table || {}), headers: (table && table.headers) ? table.headers : [], rows: (table && table.rows) ? table.rows : [] };
      renderCsvColumns();
      updateRunnerCounts();
      saveState();
      if (opts && opts.logLoaded) {
        addLog(`Loaded runner CSV: ${runnerTable.rows.length} row(s), ${runnerTable.headers.length} column(s).`);
      }
    }

    function tryLoadRunnerTableFromPastedText({ logLoaded = false } = {}) {
      const mode = $('runnerMode').value;
      if (mode !== 'csvRows') return false;
      const raw = String($('runnerText').value || '').trim();
      if (!raw) return false;
      // Expect at least a header and one row for csvRows.
      if (!raw.includes('\n') && !raw.includes('\r')) return false;
      const table = parseDelimitedTable(raw);
      if (!table.headers || table.headers.length === 0) return false;
      if (!table.rows || table.rows.length === 0) return false;
      setRunnerTable(table, { logLoaded });
      return true;
    }

    function renderCsvColumns() {
      const sel = $('singleVarColumn');
      sel.innerHTML = '';
      if (!runnerTable.headers.length) {
        sel.disabled = true;
        $('csvHints').textContent = '';
        return;
      }
      runnerTable.headers.forEach(h => {
        const opt = document.createElement('option');
        opt.value = h;
        opt.textContent = h;
        sel.appendChild(opt);
      });
      sel.disabled = false;

      // Heuristic: try to preselect the chosen variable name
      const varName = $('singleVarName').value;
      const byNorm = new Map(runnerTable.headers.map(h => [normalizeKey(h), h]));
      const found = byNorm.get(normalizeKey(varName));
      if (found) sel.value = found;
      $('csvHints').textContent = `Loaded CSV with ${runnerTable.rows.length} rows, delimiter "${runnerTable.delimiter || ','}".`;
    }

    function getIterations() {
      const enabled = $('runnerEnabled').checked;
      if (!enabled) return [{ __index: 0, vars: {} }]; // single-run fallback

      const mode = $('runnerMode').value;
      if (mode === 'csvRows') {
        // Allow CSV rows from either uploaded/dropped CSV OR pasted CSV text.
        if (!runnerTable.rows.length) {
          tryLoadRunnerTableFromPastedText({ logLoaded: false });
        }
        if (!runnerTable.rows.length) return [];
        return runnerTable.rows.map((r, i) => {
          // normalize keys so "page index" also works
          const vars = {};
          for (const [k, v] of Object.entries(r)) vars[k] = v;
          return { __index: i, vars };
        });
      }

      // single variable mode
      const varName = $('singleVarName').value;
      let values = [];

      // If CSV loaded, pull from selected column
      if (runnerTable.rows.length && !$('runnerText').value.trim()) {
        const col = $('singleVarColumn').value;
        if (col) values = runnerTable.rows.map(r => String(r[col] ?? '').trim()).filter(Boolean);
      } else {
        values = parseList($('runnerText').value);
      }

      const prefix = $('singleVarPrefix')?.value ?? '';
      const suffix = $('singleVarSuffix')?.value ?? '';
      return values.map((v, i) => ({ __index: i, vars: { [varName]: `${prefix}${v}${suffix}` } }));
    }

    function updateRunnerCounts() {
      const iters = getIterations();
      $('iterationCount').textContent = String(iters.length || 0);
    }

    function toggleRunnerUi() {
      const enabled = $('runnerEnabled').checked;
      $('runnerSection').classList.toggle('hide', !enabled);
      updateRunnerCounts();
      saveState();
    }

    function toggleSingleVarUi() {
      const mode = $('runnerMode').value;
      const isSingle = mode === 'singleVar';
      $('singleVarConfig').classList.toggle('hide', !isSingle);
      $('singleVarColumnWrap').classList.toggle('hide', !isSingle);
      updateRunnerCounts();
      saveState();
    }

    // ---------------- Execution -------------------------------------------
    let stopRequested = false;
    let isRunning = false;
    let aggregated = null;

    function setButtonsRunning(running) {
      isRunning = running;
      $('btnRunOnce').disabled = running;
      $('btnRunRunner').disabled = running;
      $('btnStop').disabled = !running;
    }

    function setProgress(total, done, status) {
      if (total <= 1) {
        $('progressWrap').classList.add('hide');
      } else {
        $('progressWrap').classList.remove('hide');
      }
      $('progressText').textContent = `${done} / ${total}`;
      $('statusText').textContent = status || 'Running';
      const pct = total ? Math.round((done / total) * 100) : 0;
      $('progressBar').style.width = `${pct}%`;
    }

    function resetStats() {
      $('completedCount').textContent = '0';
      $('failedCount').textContent = '0';
      setProgress(0, 0, 'Ready');
    }

    function normVarsMap(obj) {
      // Build a lookup for runner vars, so headers with spaces/case still match our expected keys.
      const m = new Map();
      for (const [k, v] of Object.entries(obj || {})) m.set(normalizeKey(k), v);
      return m;
    }

    function buildRunnerVars(action, iterationVarsRaw) {
      const map = normVarsMap(iterationVarsRaw || {});
      const out = {};

      // Custom mode: allow any variables (for URL/headers/body templating)
      if (action.erp === 'custom') {
        for (const [k, v] of Object.entries(iterationVarsRaw || {})) {
          const kk = String(k ?? '').trim();
          if (!kk) continue;
          if (v === undefined || v === null) continue;
          out[kk] = String(v).trim();
        }
        // normalize common keys too
        ['payerPublicId','searchId','pageIndex','pageSize','fetchAll','where','method','url'].forEach((k) => {
          const v = map.get(normalizeKey(k));
          if (v !== undefined) out[k] = String(v).trim();
        });
        return out;
      }

      // Path placeholders
      extractPlaceholders(action.path).forEach((p) => {
        const v = map.get(normalizeKey(p));
        if (v !== undefined) out[p] = String(v).trim();
      });

      // Query params (requested)
      ['searchId','pageIndex','pageSize','fetchAll','where'].forEach((k) => {
        const v = map.get(normalizeKey(k));
        if (v !== undefined) out[k] = String(v).trim();
      });

      return out;
    }

    async function fetchWithTimeout(url, opts, timeoutMs) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        return res;
      } finally {
        clearTimeout(timer);
      }
    }

    function getProxyUrl() {
      const base = String($('proxyBaseUrl').value || '').trim().replace(/\/+$/, '');
      return base ? (base + '/proxy') : '';
    }

    async function callViaProxy({ url, method, headers, timeoutMs, body }) {
      const proxyUrl = getProxyUrl();
      if (!proxyUrl) throw new Error('Proxy is enabled but proxy base URL is empty.');
      const res = await fetchWithTimeout(proxyUrl, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ url, method, headers, timeoutMs, body }),
      }, timeoutMs);
      if (!res.ok) {
        const t = await res.text();
        throw new Error(`Proxy error (${res.status}): ${t.slice(0, 400)}`);
      }
      return await res.json();
    }

    async function runRequests({ runnerMode }) {
      const action = getSelectedAction();
      if (!action) { alert('Missing action selection'); return; }

      const isCustom = action.erp === 'custom';
      if (isCustom && !$('customUrl').value.trim()) { alert('Missing Custom URL'); return; }

      const token = $('bearerToken').value.trim();
      if (!isCustom && !token) { alert('Missing bearer token'); return; }
      if (isCustom && $('customIncludeAuth').checked && !token) { alert('Missing bearer token (or uncheck "Add Authorization")'); return; }

      const env = $('environment').value;
      const delayMs = Math.max(0, Number($('delayMs').value || 0));
      const timeoutMs = Math.max(1000, Number($('timeoutMs').value || 30000));
      const useProxy = $('useProxy').checked;

      const baseVars = getBaseVarsFromUi(action);

      const iterations = (runnerMode === 'runner') ? getIterations() : [{ __index: 0, vars: {} }];
      if (runnerMode === 'runner' && !iterations.length) {
        alert('Runner mode is enabled but no iterations were found. Paste values or upload a CSV.');
        return;
      }

      stopRequested = false;
      setButtonsRunning(true);
      clearLogs();
      resetStats();

      aggregated = {
        meta: {
          startedAt: nowIso(),
          environment: env,
          erp: action.erp,
          actionKey: action.key,
          actionName: action.name,
          method: action.method,
          pathTemplate: isCustom ? $('customUrl').value.trim() : action.path,
          delayMs,
          timeoutMs,
          runner: {
            enabled: runnerMode === 'runner' && $('runnerEnabled').checked,
            mode: $('runnerEnabled').checked ? $('runnerMode').value : 'off',
            iterationCount: iterations.length,
          }
        },
        results: []
      };

      refreshAggregatedOutput();
      let completed = 0;
      let failed = 0;

      addLog(`Starting ${iterations.length} request(s)…`);
      const total = iterations.length;
      setProgress(total, 0, 'Running');

      for (let i = 0; i < iterations.length; i++) {
        if (stopRequested) {
          addLog('Stop requested — ending after current iteration.');
          break;
        }

        const iter = iterations[i];
        const runnerVars = buildRunnerVars(action, iter.vars);
        let url = '';
        let method = (action.method || 'GET').toUpperCase();
        let reqHeaders = null;
        let reqBody = null;

        if (isCustom) {
          const vars = { ...baseVars, ...(runnerVars || {}) };
          const urlTemplate = String(runnerVars.url ?? $('customUrl').value ?? '').trim();
          url = buildCustomUrl({ baseUrl: urlTemplate, vars, qpRows: getCustomQpRows() });
          method = String((runnerVars.method ?? $('customMethod').value) || 'GET').toUpperCase();

          const headersTemplate = applyTemplate($('customHeaders').value || '', vars);
          reqHeaders = parseHeadersInput(headersTemplate);
          if ($('customIncludeAuth').checked) reqHeaders['authorization'] = `Bearer ${token}`;
          if (!reqHeaders['accept'] && !reqHeaders['Accept']) reqHeaders['accept'] = 'application/json';

          const bodyTemplate = applyTemplate($('customBody').value || '', vars);
          if (bodyTemplate.trim() && !['GET','HEAD'].includes(method)) reqBody = bodyTemplate;
        } else {
          url = buildFinalUrl({ action, env, baseVars, runnerVars });
          if (url.includes('{') || url.includes('}')) {
            stopRequested = true;
            addLog(`  ↳ BLOCKED: missing placeholder values. URL still contains "{...}".`);
            alert('Missing required path parameters (URL still contains "{...}"). Fill placeholders or provide them via runner CSV columns.');
            break;
          }
          method = (action.method || 'GET').toUpperCase();
          reqHeaders = {
            'accept': 'application/json',
            'authorization': `Bearer ${token}`,
          };
        }

        const startedAt = performance.now();
        addLog(`(${i + 1}/${total}) ${method} ${url}`);

        let res = null;
        let bodyJson = null;
        let bodyText = null;
        let ok = false;
        let status = 0;
        let error = null;

        try {
          if (useProxy) {
            const proxyResp = await callViaProxy({ url, method, headers: reqHeaders, timeoutMs, body: reqBody });
            status = Number(proxyResp.status || 0);
            ok = Boolean(proxyResp.ok);
            const ct = String((proxyResp.headers && (proxyResp.headers['content-type'] || proxyResp.headers['Content-Type'])) || '');
            bodyText = String(proxyResp.bodyText ?? '');
            if (ct.includes('application/json')) {
              try { bodyJson = JSON.parse(bodyText || ''); bodyText = null; } catch {}
            } else {
              try { bodyJson = JSON.parse(bodyText || ''); bodyText = null; } catch {}
            }
          } else {
            const fetchOpts = { method, headers: reqHeaders };
            if (reqBody !== null && reqBody !== undefined) fetchOpts.body = reqBody;
            res = await fetchWithTimeout(url, fetchOpts, timeoutMs);
            status = res.status;
            ok = res.ok;

            const ct = res.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
              try { bodyJson = await res.json(); }
              catch (e) { bodyText = await res.text(); }
            } else {
              bodyText = await res.text();
              // Try parse JSON anyway
              try { bodyJson = JSON.parse(bodyText); bodyText = null; } catch {}
            }
          }
        } catch (e) {
          error = String(e && e.name === 'AbortError' ? `Timeout after ${timeoutMs}ms` : e);
          if (!useProxy && String(error).includes('Failed to fetch')) {
            addLog('  ↳ Likely browser CORS/CORP or VPN/DNS. Enable "Use local proxy" and run the proxy script.');
          }
        }

        const elapsedMs = Math.round(performance.now() - startedAt);

        if (error || !ok) {
          failed++;
          $('failedCount').textContent = String(failed);
          addLog(`  ↳ FAILED (${status || 'no status'}) in ${elapsedMs}ms ${error ? `— ${error}` : ''}`);
        } else {
          completed++;
          $('completedCount').textContent = String(completed);
          addLog(`  ↳ OK (${status}) in ${elapsedMs}ms`);
        }

        aggregated.results.push({
          iteration: i,
          input: {
            runnerVarsRaw: iter.vars,
            resolvedVars: runnerVars,
          },
          request: { method: (action.method || 'GET').toUpperCase(), url },
          response: {
            ok,
            status,
            elapsedMs,
            contentType: res ? (res.headers.get('content-type') || '') : '',
            error,
          },
          body: bodyJson !== null ? bodyJson : undefined,
          rawText: bodyJson === null ? (bodyText ?? null) : null,
        });

        // Update aggregated output progressively (so you can copy even mid-run)
        refreshAggregatedOutput();

        setProgress(total, i + 1, stopRequested ? 'Stopping…' : 'Running');

        if (i < iterations.length - 1 && delayMs > 0) await sleep(delayMs);
      }

      aggregated.meta.completedAt = nowIso();
      aggregated.meta.summary = {
        total: iterations.length,
        completed,
        failed,
        stopped: stopRequested,
      };
      refreshAggregatedOutput();

      setProgress(total, Math.min(total, aggregated.results.length), stopRequested ? 'Stopped' : 'Done');
      addLog(`Done. completed=${completed} failed=${failed} stopped=${stopRequested}`);

      setButtonsRunning(false);
    }

    // ---------------- UI Actions ------------------------------------------
    function clearAll() {
      if (isRunning) return;
      $('bearerToken').value = '';
      $('payerPublicId').value = '';
      $('rememberToken').checked = false;
      $('delayMs').value = '1500';
      $('timeoutMs').value = '30000';
      $('useProxy').checked = false;
      $('proxyBaseUrl').value = 'http://localhost:8787';
      $('qpSearchId').value = '';
      $('qpPageIndex').value = '';
      $('qpPageSize').value = '';
      $('qpFetchAll').value = '';
      $('qpWhere').value = '';
      if ($('customMethod')) $('customMethod').value = 'GET';
      if ($('customIncludeAuth')) $('customIncludeAuth').checked = true;
      if ($('customUrl')) $('customUrl').value = '';
      customQpRows = [{ k: '', v: '' }];
      renderCustomQpRows();
      if ($('customHeaders')) $('customHeaders').value = '';
      if ($('customBody')) $('customBody').value = '';
      $('runnerEnabled').checked = false;
      $('runnerMode').value = 'singleVar';
      $('runnerText').value = '';
      $('runnerCsvFile').value = '';
      runnerTable = { headers: [], rows: [] };
      renderCsvColumns();
      toggleRunnerUi();
      clearLogs();
      resetStats();
      $('aggOut').value = '';
      if ($('aggMode')) $('aggMode').value = 'full';
      setTokenStatus();
      try { localStorage.removeItem(STORAGE_KEY); } catch {}
      updateUrlPreview();
    }

    async function copyAgg() {
      const txt = $('aggOut').value || '';
      if (!txt.trim()) { alert('Nothing to copy yet. Run a request first.'); return; }
      try {
        await navigator.clipboard.writeText(txt);
        $('btnCopyAgg').classList.add('copied');
        $('btnCopyAgg').textContent = 'Copied';
        setTimeout(() => { $('btnCopyAgg').classList.remove('copied'); $('btnCopyAgg').textContent = 'Copy aggregated JSON'; }, 900);
      } catch {
        prompt('Copy aggregated JSON:', txt);
      }
    }

    function downloadAgg() {
      const txt = $('aggOut').value || '';
      if (!txt.trim()) { alert('Nothing to download yet. Run a request first.'); return; }
      const blob = new Blob([txt], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `syncapp_erp_api_runner_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(a.href);
        a.remove();
      }, 0);
    }

    async function pasteRunner() {
      try {
        const text = await navigator.clipboard.readText();
        $('runnerText').value = text;
        updateRunnerCounts();
        saveState();
      } catch {
        alert('Unable to read from clipboard. Paste manually (Ctrl/Cmd+V).');
      }
    }

    function genPageIndexRange() {
      const start = prompt('Start pageIndex (integer):', '0');
      if (start === null) return;
      const end = prompt('End pageIndex (integer, inclusive):', '10');
      if (end === null) return;
      const step = prompt('Step:', '1');
      if (step === null) return;
      const s = Number(start), e = Number(end), st = Number(step);
      if (!Number.isInteger(s) || !Number.isInteger(e) || !Number.isInteger(st) || st === 0) {
        alert('Invalid range. Please enter integers and non-zero step.');
        return;
      }
      const vals = [];
      if (st > 0) for (let x = s; x <= e; x += st) vals.push(String(x));
      else for (let x = s; x >= e; x += st) vals.push(String(x));
      $('runnerText').value = vals.join('\n');
      $('singleVarName').value = 'pageIndex';
      updateRunnerCounts();
      saveState();
    }

    // ---------------- Wire up events --------------------------------------
    const SECTIONS_KEY = STORAGE_KEY + '_sections';
    let actionComboOpen = false;
    let actionComboPrevLabel = '';
    let actionComboHasTyped = false;

    function getSelectedActionLabel() {
      const sel = $('actionSelect');
      const opt = sel && sel.selectedOptions && sel.selectedOptions[0];
      return opt ? String(opt.textContent || '') : '';
    }

    function syncActionComboDisplay() {
      const inp = $('actionComboInput');
      if (!inp) return;
      if (actionComboOpen) return;
      inp.value = getSelectedActionLabel();
    }

    function renderActionComboList() {
      const list = $('actionComboList');
      if (!list) return;
      list.innerHTML = '';

      const erp = $('erp').value;
      const reg = MASTER_REGISTRY[erp] || {};
      const q = actionComboHasTyped ? String($('actionComboInput')?.value || '').trim().toLowerCase() : '';
      const keys = Object.keys(reg).sort((a,b) => Number(a) - Number(b));

      let shown = 0;
      for (const k of keys) {
        const item = reg[k];
        const label = `[${k}] ${item.name}`;
        const hay = `${label} ${item.path}`.toLowerCase();
        if (q && !hay.includes(q)) continue;

        const row = document.createElement('div');
        row.className = 'combo-item';
        row.textContent = label;
        row.addEventListener('click', () => {
          $('actionSelect').value = k;
          $('actionSelect').dispatchEvent(new Event('change'));
          closeActionCombo();
        });
        list.appendChild(row);
        shown++;
        if (shown >= 80) break;
      }

      if (shown === 0) {
        const empty = document.createElement('div');
        empty.className = 'muted small';
        empty.textContent = 'No matches';
        list.appendChild(empty);
      }
    }

    function openActionCombo() {
      const pop = $('actionComboPop');
      if (!pop) return;
      if (actionComboOpen) return;
      actionComboPrevLabel = getSelectedActionLabel();
      actionComboHasTyped = false;
      actionComboOpen = true;
      pop.classList.remove('hide');
      const inp = $('actionComboInput');
      if (inp) {
        inp.focus();
        inp.value = actionComboPrevLabel;
        inp.select();
      }
      renderActionComboList();
    }

    function closeActionCombo() {
      const pop = $('actionComboPop');
      if (!pop) return;
      if (!actionComboOpen) return;
      actionComboOpen = false;
      pop.classList.add('hide');
      const inp = $('actionComboInput');
      if (inp) inp.value = getSelectedActionLabel() || actionComboPrevLabel;
    }

    function setCardCollapsed(card, collapsed) {
      if (!card) return;
      card.classList.toggle('collapsed', Boolean(collapsed));
      const btn = card.querySelector('.section-toggle');
      if (btn) btn.textContent = card.classList.contains('collapsed') ? 'Expand' : 'Collapse';
    }

    function saveSectionState() {
      try {
        const collapsed = [...document.querySelectorAll('.card[data-section].collapsed')].map(c => c.dataset.section);
        localStorage.setItem(SECTIONS_KEY, JSON.stringify(collapsed));
      } catch {}
    }

    function loadSectionState() {
      try {
        const raw = localStorage.getItem(SECTIONS_KEY);
        if (!raw) return;
        const collapsed = new Set(JSON.parse(raw) || []);
        document.querySelectorAll('.card[data-section]').forEach(card => {
          setCardCollapsed(card, collapsed.has(card.dataset.section));
        });
      } catch {}
    }

    function expandAllSections() {
      document.querySelectorAll('.card[data-section]').forEach(card => setCardCollapsed(card, false));
      saveSectionState();
    }

    function collapseAllSections() {
      document.querySelectorAll('.card[data-section]').forEach(card => setCardCollapsed(card, true));
      saveSectionState();
    }

    $('btnExpandAll').addEventListener('click', expandAllSections);
    $('btnCollapseAll').addEventListener('click', collapseAllSections);
    document.querySelectorAll('.section-toggle').forEach(btn => {
      btn.addEventListener('click', () => {
        const sectionId = btn.dataset.toggle;
        const card = document.querySelector(`.card[data-section="${CSS.escape(sectionId)}"]`);
        if (!card) return;
        setCardCollapsed(card, !card.classList.contains('collapsed'));
        saveSectionState();
      });
    });

    $('btnClearAll').addEventListener('click', clearAll);
    $('btnClearToken').addEventListener('click', () => {
      $('bearerToken').value = '';
      setTokenStatus();
      saveState();
    });
    $('bearerToken').addEventListener('input', () => { setTokenStatus(); saveState(); });
    $('payerPublicId').addEventListener('input', () => { updateUrlPreview(); renderSingleVarCandidates(); saveState(); });
    $('rememberToken').addEventListener('change', () => { saveState(); });
    $('useProxy').addEventListener('change', () => { saveState(); });
    $('proxyBaseUrl').addEventListener('input', () => { warnIfMixedContentProxy(); saveState(); });
    $('environment').addEventListener('change', () => { updateUrlPreview(); });
    $('erp').addEventListener('change', () => {
      renderActionOptions();
      renderPathParams();
      updateUrlPreview();
      saveState();
    });

    // Action: click to open dropdown; typing filters options (no extra section)
    $('actionComboBtn').addEventListener('click', () => {
      if (actionComboOpen) closeActionCombo();
      else openActionCombo();
    });
    $('actionComboInput').addEventListener('focus', openActionCombo);
    $('actionComboInput').addEventListener('click', openActionCombo);
    $('actionComboInput').addEventListener('input', () => {
      if (!actionComboOpen) openActionCombo();
      actionComboHasTyped = true;
      renderActionComboList();
    });
    $('actionComboPop').addEventListener('mousedown', (e) => { e.preventDefault(); });
    document.addEventListener('click', (e) => {
      if (!actionComboOpen) return;
      const combo = $('actionCombo');
      if (combo && combo.contains(e.target)) return;
      closeActionCombo();
    });
    $('customMethod').addEventListener('change', () => { renderSingleVarCandidates(); updateUrlPreview(); saveState(); });
    $('customIncludeAuth').addEventListener('change', () => { saveState(); });
    $('customUrl').addEventListener('input', () => { renderSingleVarCandidates(); updateUrlPreview(); saveState(); });
    $('customHeaders').addEventListener('input', () => { renderSingleVarCandidates(); saveState(); });
    $('customBody').addEventListener('input', () => { renderSingleVarCandidates(); saveState(); });
    $('btnImportCurl').addEventListener('click', importCurlToCustomApi);
    $('btnClearCurl').addEventListener('click', () => { $('customCurl').value = ''; });
    $('btnCustomAddQp').addEventListener('click', () => {
      customQpRows.push({ k: '', v: '' });
      renderCustomQpRows();
      updateUrlPreview();
      saveState();
    });

    $('actionSelect').addEventListener('change', () => { syncActionComboDisplay(); renderPathParams(); updateUrlPreview(); saveState(); });
    ['qpSearchId','qpPageIndex','qpPageSize','qpFetchAll','qpWhere','delayMs','timeoutMs'].forEach(id => {
      $(id).addEventListener('input', () => { updateUrlPreview(); updateRunnerCounts(); saveState(); });
      $(id).addEventListener('change', () => { updateUrlPreview(); updateRunnerCounts(); saveState(); });
    });

    $('runnerEnabled').addEventListener('change', toggleRunnerUi);
    $('runnerMode').addEventListener('change', () => { toggleSingleVarUi(); updateRunnerCounts(); });
    $('singleVarName').addEventListener('change', () => { renderCsvColumns(); updateRunnerCounts(); saveState(); });
    $('singleVarColumn').addEventListener('change', () => { updateRunnerCounts(); saveState(); });
    $('runnerText').addEventListener('input', () => {
      // If the user is in CSV rows mode, treat the textarea as pasted CSV/TSV (with header row).
      // Otherwise, it remains the single-variable list input.
      tryLoadRunnerTableFromPastedText({ logLoaded: false });
      updateRunnerCounts();
      saveState();
    });
    $('singleVarPrefix').addEventListener('input', () => { updateRunnerCounts(); saveState(); });
    $('singleVarSuffix').addEventListener('input', () => { updateRunnerCounts(); saveState(); });

    $('runnerCsvFile').addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const table = parseDelimitedTable(text);
        setRunnerTable(table, { logLoaded: true });
      } catch (err) {
        alert('Failed to read CSV: ' + String(err));
      }
    });

    // Drag & drop: CSV/TSV into runner dropzone (same behavior as file upload)
    (function initRunnerDropZone() {
      const dz = $('runnerDropZone');
      if (!dz) return;

      function setDragOver(on) {
        dz.classList.toggle('dragover', Boolean(on));
      }

      dz.addEventListener('dragenter', (e) => {
        e.preventDefault();
        setDragOver(true);
      });
      dz.addEventListener('dragover', (e) => {
        e.preventDefault();
        setDragOver(true);
      });
      dz.addEventListener('dragleave', (e) => {
        e.preventDefault();
        setDragOver(false);
      });
      dz.addEventListener('drop', async (e) => {
        e.preventDefault();
        setDragOver(false);
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const table = parseDelimitedTable(text);
          setRunnerTable(table, { logLoaded: true });
          // Keep file input in sync when possible (optional, best-effort)
          try { $('runnerCsvFile').value = ''; } catch {}
        } catch (err) {
          alert('Failed to read dropped file: ' + String(err));
        }
      });
    })();

    $('btnPasteRunner').addEventListener('click', pasteRunner);
    $('btnClearRunner').addEventListener('click', () => {
      $('runnerText').value = '';
      $('runnerCsvFile').value = '';
      runnerTable = { headers: [], rows: [] };
      renderCsvColumns();
      updateRunnerCounts();
      saveState();
    });
    $('btnGenPageIndex').addEventListener('click', genPageIndexRange);

    $('btnRunOnce').addEventListener('click', () => runRequests({ runnerMode: 'once' }));
    $('btnRunRunner').addEventListener('click', () => runRequests({ runnerMode: 'runner' }));
    $('btnStop').addEventListener('click', () => { stopRequested = true; addLog('Stop requested.'); });
    $('btnClearResults').addEventListener('click', () => {
      if (isRunning) return;
      clearLogs();
      resetStats();
      aggregated = null;
      $('aggOut').value = '';
    });
    $('btnCopyAgg').addEventListener('click', copyAgg);
    $('btnDownloadAgg').addEventListener('click', downloadAgg);
    $('aggMode').addEventListener('change', () => { refreshAggregatedOutput(); saveState(); });

    // ---------------- Init -------------------------------------------------
    (function init() {
      renderActionOptions();
      renderPathParams();
      loadState();
      applyUrlConfig();
      warnIfMixedContentProxy();
      loadSectionState();
      renderCustomQpRows();
      // After loading state, rerender registry-dependent UI
      renderActionOptions();
      if (savedActionKey && [...$('actionSelect').options].some(o => o.value === savedActionKey)) {
        $('actionSelect').value = savedActionKey;
      }
      // Restore action selection if saved
      if ($('actionSelect').options.length) {
        // keep current selection
      }
      renderPathParams();
      toggleRunnerUi();
      toggleSingleVarUi();
      setTokenStatus();
      syncActionComboDisplay();
      updateUrlPreview();
      updateRunnerCounts();
      refreshAggregatedOutput();
    })();
  </script>
</body>
</html>


